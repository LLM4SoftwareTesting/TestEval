{"task_num": 4, "task_title": "Median of Two Sorted Arrays", "difficulty": 3, "func_name": "findMedianSortedArrays", "description": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively,\nreturn the median of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        if (n1 + n2) % 2 == 0:\n          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5\n        else:\n          return max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.53}, {"type": "if", "start": 28, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.51}, {"type": "else", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.49}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.92}, {"type": "else", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [16, 29, 30, 32, 34, 36]}
{"task_num": 10, "task_title": "Regular Expression Matching", "difficulty": 3, "func_name": "isMatch", "description": "Given an input string `s` and a pattern `p`, implement regular expression\nmatching with support for `'.'` and `'*'` where:\n\n* `'.'` Matches any single character.\u200b\u200b\u200b\u200b\n* `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 27, "end": 30, "difficulty": 2, "eg_cov_prob": 0.26}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [23, 28, 29, 30, 32]}
{"task_num": 15, "task_title": "3Sum", "difficulty": 2, "func_name": "threeSum", "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j],\nnums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] +\nnums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSum(self, nums: List[int]) -> List[List[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.83}, {"type": "if", "start": 28, "end": 35, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 22, 29, 30, 31, 32, 33, 34, 35, 37, 39]}
{"task_num": 44, "task_title": "Wildcard Matching", "difficulty": 3, "func_name": "isMatch", "description": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern\nmatching with support for `'?'` and `'*'` where:\n\n* `'?'` Matches any single character.\n* `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 27, "end": 30, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28, 29, 30, 32]}
{"task_num": 54, "task_title": "Spiral Matrix", "difficulty": 2, "func_name": "spiralOrder", "description": "Given an `m x n` `matrix`, return all elements of the `matrix` in spiral\norder.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14]}
{"task_num": 65, "task_title": "Valid Number", "difficulty": 3, "func_name": "isNumber", "description": "A valid number can be split up into these components (in order):\n\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats: \n1. One or more digits, followed by a dot `'.'`.\n2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n3. A dot `'.'`, followed by one or more digits.\n\nAn integer can be split up into these components (in order):\n\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One or more digits.\n\nFor example, all the following are valid numbers: `[\"2\", \"0089\", \"-0.1\",\n\"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\",\n\"-123.456e789\"]`, while the following are not valid numbers: `[\"abc\", \"1a\",\n\"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return `true` if `s` is a valid number.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 22, "end": 25, "difficulty": 2, "eg_cov_prob": 0.24}, {"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.37}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.11}, {"type": "if", "start": 31, "end": 34, "difficulty": 2, "eg_cov_prob": 0.29}, {"type": "else", "start": 35, "end": 38, "difficulty": 1, "eg_cov_prob": 0.85}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.43}], "target_lines": [15, 23, 24, 25, 27, 28, 29, 30, 32, 33, 34, 36, 37, 38]}
{"task_num": 73, "task_title": "Set Matrix Zeroes", "difficulty": 2, "func_name": "setZeroes", "description": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire\nrow and column to `0`'s.\n\nYou must do it in place.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def setZeroes(self, matrix: List[List[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 20, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [21, 22, 27, 30, 33, 34]}
{"task_num": 97, "task_title": "Interleaving String", "difficulty": 2, "func_name": "isInterleave", "description": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an\ninterleaving of `s1` and `s2`.\n\nAn interleaving of two strings `s` and `t` is a configuration where `s` and\n`t` are divided into `n` and `m` substrings respectively, such that:\n\n* `s = s1 + s2 + ... + sn`\n* `t = t1 + t2 + ... + tm`\n* `|n - m| <= 1`\n* The interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\nNote: `a + b` is the concatenation of strings `a` and `b`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    dp=[]\n    for _ in range(m + 1):\n      dp.append([False] * (n + 1))\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [16]}
{"task_num": 126, "task_title": "Word Ladder II", "difficulty": 3, "func_name": "findLadders", "description": "A transformation sequence from word `beginWord` to word `endWord` using a\ndictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->\nsk` such that:\n\n* Every adjacent pair of words differs by a single letter.\n* Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n* `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`,\nreturn all the shortest transformation sequences from `beginWord` to\n`endWord`, or an empty list if no such sequence exists. Each sequence should\nbe returned as a list of the words `[beginWord, s1, s2, ..., sk]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n    from collections import deque\n    def connected(a: str, b: str) -> bool:\n      k = 0\n      for i in range(len(a)):\n        if a[i] != b[i]:\n          k += 1\n      return k == 1\n\n    if endWord not in wordList:\n      return []\n\n    visited = set([beginWord])\n\n    q = deque([beginWord])\n    nodes = []\n    find = False\n\n    while q and not find:\n      nodes.append(q.copy())\n      n = len(q)\n      for _ in range(n):\n        word = q.popleft()\n        for item in wordList:\n          if item in visited:\n            continue\n          if not connected(word, item):\n            continue\n          if item == endWord:\n            find = True\n            break\n          visited.add(item)\n          q.append(item)\n        if find:\n          break\n\n    if not find:\n      return []\n\n    ans = []\n\n    def backtracking(word, level: int, steps: List[str]):\n      if word == beginWord:\n        ans.append(steps[::-1])\n        return\n      if level < 0:\n        return\n      for item in nodes[level]:\n        if connected(item, word):\n          steps.append(item)\n          backtracking(item, level-1, steps)\n          steps.pop()\n\n    backtracking(endWord, len(nodes)-1, [endWord])\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 54, "end": 56, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 60, "end": 63, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 40, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [18, 22, 37, 39, 41, 42, 46, 49, 55, 56, 58, 61, 62, 63]}
{"task_num": 130, "task_title": "Surrounded Regions", "difficulty": 2, "func_name": "solve", "description": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, capture all\nregions that are 4-directionally surrounded by `'X'`.\n\nA region is captured by flipping all `'O'`s into `'X'`s in that surrounded\nregion.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        if c == '*':\n          row[i] = 'O'\n        else:\n          row[i] = 'X'\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 23, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 24, 25, 26, 34, 36, 43, 45]}
{"task_num": 132, "task_title": "Palindrome Partitioning II", "difficulty": 3, "func_name": "minCut", "description": "Given a string `s`, partition `s` such that every substring of the partition\nis a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    isPalindrome=[]\n    for _ in range(n):\n      isPalindrome.append([True] * n)\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]\n", "blocks": [{"type": "if", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 28, 32]}
{"task_num": 218, "task_title": "The Skyline Problem", "difficulty": 3, "func_name": "getSkyline", "description": "A city's skyline is the outer contour of the silhouette formed by all the\nbuildings in that city when viewed from a distance. Given the locations and\nheights of all the buildings, return the skyline formed by these buildings\ncollectively.\n\nThe geometric information of each building is given in the array `buildings`\nwhere `buildings[i] = [lefti, righti, heighti]`:\n\n* `lefti` is the x coordinate of the left edge of the `ith` building.\n* `righti` is the x coordinate of the right edge of the `ith` building.\n* `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely\nflat surface at height `0`.\n\nThe skyline should be represented as a list of \"key points\" sorted by their\nx-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left\nendpoint of some horizontal segment in the skyline except the last point in\nthe list, which always has a y-coordinate `0` and is used to mark the\nskyline's termination where the rightmost building ends. Any ground between\nthe leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the\noutput skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is\nnot acceptable; the three lines of height 5 should be merged into one in the\nfinal output as such: `[...,[2 3],[4 5],[12 7],...]`\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:\n    ans = []\n    i = 0\n    j = 0\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 16, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [15, 17, 18, 33, 34, 35, 37, 38, 39, 53, 54, 56]}
{"task_num": 227, "task_title": "Basic Calculator II", "difficulty": 2, "func_name": "calculate", "description": "Given a string `s` which represents an expression, evaluate this expression\nand return its value.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate\nresults will be in the range of `[-231, 231 - 1]`.\n\nNote: You are not allowed to use any built-in function which evaluates strings\nas mathematical expressions, such as `eval()`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 24, 25, 26, 27, 28, 29, 31, 32, 33]}
{"task_num": 289, "task_title": "Game of Life", "difficulty": 2, "func_name": "gameOfLife", "description": "According to Wikipedia's article: \"The Game of Life, also known simply as\nLife, is a cellular automaton devised by the British mathematician John Horton\nConway in 1970.\"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an\ninitial state: live (represented by a `1`) or dead (represented by a `0`).\nEach cell interacts with its eight neighbors (horizontal, vertical, diagonal)\nusing the following four rules (taken from the above Wikipedia article):\n\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies, as if by over-population.\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every\ncell in the current state, where births and deaths occur simultaneously. Given\nthe current state of the `m x n` grid `board`, return the next state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gameOfLife(self, board: List[List[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [24, 27]}
{"task_num": 310, "task_title": "Minimum Height Trees", "difficulty": 2, "func_name": "findMinHeightTrees", "description": "A tree is an undirected graph in which any two vertices are connected by\nexactly one path. In other words, any connected graph without simple cycles is\na tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n -\n1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected\nedge between the two nodes `ai` and `bi` in the tree, you can choose any node\nof the tree as the root. When you select a node `x` as the root, the result\ntree has height `h`. Among all possible rooted trees, those with minimum\nheight (i.e. `min(h)`) are called minimum height trees (MHTs).\n\nReturn a list of all MHTs' root labels. You can return the answer in any\norder.\n\nThe height of a rooted tree is the number of edges on the longest downward\npath between the root and a leaf.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 25, 34]}
{"task_num": 327, "task_title": "Count of Range Sum", "difficulty": 3, "func_name": "countRangeSum", "description": "Given an integer array `nums` and two integers `lower` and `upper`, return the\nnumber of range sums that lie in `[lower, upper]` inclusive.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between\nindices `i` and `j` inclusive, where `i <= j`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = [0] + list(itertools.accumulate(nums))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:\n    lo = m + 1\n    hi = m + 1\n\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0\n    i = l\n    j = m + 1\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 50, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 47, 48, 49, 51, 52, 53]}
{"task_num": 335, "task_title": "Self Crossing", "difficulty": 3, "func_name": "isSelfCrossing", "description": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an X-Y plane, and you move `distance[0]`\nmeters to the north, then `distance[1]` meters to the west, `distance[2]`\nmeters to the south, `distance[3]` meters to the east, and so on. In other\nwords, after each move, your direction changes counter-clockwise.\n\nReturn `true` if your path crosses itself or `false` if it does not.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isSelfCrossing(self, x: List[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09}], "target_lines": [14, 18, 20, 22]}
{"task_num": 336, "task_title": "Palindrome Pairs", "difficulty": 3, "func_name": "palindromePairs", "description": "You are given a 0-indexed array of unique strings `words`.\n\nA palindrome pair is a pair of integers `(i, j)` such that:\n\n* `0 <= i, j < words.length`,\n* `i != j`, and\n* `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of `words`.\n\nYou must write an algorithm with `O(sum of words[i].length)` runtime\ncomplexity.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def palindromePairs(self, words: List[str]) -> List[List[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.72}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [18, 24, 26]}
{"task_num": 391, "task_title": "Perfect Rectangle", "difficulty": 3, "func_name": "isRectangleCover", "description": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]`\nrepresents an axis-aligned rectangle. The bottom-left point of the rectangle\nis `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` if all the rectangles together form an exact cover of a\nrectangular region.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: Set[Tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:\n      return False\n    return area == (x2 - x1) * (y2 - y1)\n", "blocks": [{"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.47}, {"type": "else", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [29, 31, 34, 36]}
{"task_num": 402, "task_title": "Remove K Digits", "difficulty": 2, "func_name": "removeKdigits", "description": "Given string num representing a non-negative integer `num`, and an integer\n`k`, return the smallest possible integer after removing `k` digits from\n`num`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 30]}
{"task_num": 407, "task_title": "Trapping Rain Water II", "difficulty": 3, "func_name": "trapRainWater", "description": "Given an `m x n` integer matrix `heightMap` representing the height of each\nunit cell in a 2D elevation map, return the volume of water it can trap after\nraining.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def trapRainWater(self, heightMap: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 43, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "else", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [38, 40, 42, 43, 45]}
{"task_num": 417, "task_title": "Pacific Atlantic Water Flow", "difficulty": 2, "func_name": "pacificAtlantic", "description": "There is an `m x n` rectangular island that borders both the Pacific Ocean and\nAtlantic Ocean. The Pacific Ocean touches the island's left and top edges, and\nthe Atlantic Ocean touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x\nn` integer matrix `heights` where `heights[r][c]` represents the height above\nsea level of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring\ncells directly north, south, east, and west if the neighboring cell's height\nis less than or equal to the current cell's height. Water can flow from any\ncell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [ri, ci]`\ndenotes that rain water can flow from cell `(ri, ci)` to both the Pacific and\nAtlantic oceans.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: collections.deque, seen: List[List[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    res=[]\n    for i in range(m):\n      for j in range(n):\n        if seenP[i][j] and seenA[i][j]:\n          res.append([i, j])\n    return res\n", "blocks": [{"type": "if", "start": 53, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [41, 43, 54]}
{"task_num": 420, "task_title": "Strong Password Checker", "difficulty": 3, "func_name": "strongPasswordChecker", "description": "A password is considered strong if the below conditions are all met:\n\n* It has at least `6` characters and at most `20` characters.\n* It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.\n* It does not contain three repeating characters in a row (i.e., `\"Baaabb0\"` is weak, but `\"Baaba0\"` is strong).\n\nGiven a string `password`, return the minimum number of steps required to make\n`password` strong. if `password` is already strong, return `0`.\n\nIn one step, you can:\n\n* Insert one character to `password`,\n* Delete one character from `password`, or\n* Replace one character of `password` with another character.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    replaces = 0\n    oneSeq = 0\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    replaces -= min(oneSeq, deletes)\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 21, "end": 30, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "else", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 35, 37]}
{"task_num": 423, "task_title": "Reconstruct Original Digits from English", "difficulty": 2, "func_name": "originalDigits", "description": "Given a string `s` containing an out-of-order English representation of digits\n`0-9`, return the digits in ascending order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 19, 21, 23, 25, 27, 29, 31, 33, 35]}
{"task_num": 457, "task_title": "Circular Array Loop", "difficulty": 2, "func_name": "circularArrayLoop", "description": "You are playing a game involving a circular array of non-zero integers `nums`.\nEach `nums[i]` denotes the number of indices forward/backward you must move if\nyou are located at index `i`:\n\n* If `nums[i]` is positive, move `nums[i]` steps forward, and\n* If `nums[i]` is negative, move `nums[i]` steps backward.\n\nSince the array is circular, you may assume that moving forward from the last\nelement puts you on the first element, and moving backwards from the first\nelement puts you on the last element.\n\nA cycle in the array consists of a sequence of indices `seq` of length `k`\nwhere:\n\n* Following the movement rules above results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`\n* Every `nums[seq[j]]` is either all positive or all negative.\n* `k > 1`\n\nReturn `true` if there is a cycle in `nums`, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def circularArrayLoop(self, nums: List[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 26, "end": 29, "difficulty": 2, "eg_cov_prob": 0.2}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.09}], "target_lines": [17, 21, 27, 28, 29]}
{"task_num": 524, "task_title": "Longest Word in Dictionary through Deleting", "difficulty": 2, "func_name": "findLongestWord", "description": "Given a string `s` and a string array `dictionary`, return the longest string\nin the dictionary that can be formed by deleting some of the given string\ncharacters. If there is more than one possible result, return the longest word\nwith the smallest lexicographical order. If there is no possible result,\nreturn the empty string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLongestWord(self, s: str, d: List[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 22, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.89}], "target_lines": [19, 21, 22]}
{"task_num": 542, "task_title": "01 Matrix", "difficulty": 2, "func_name": "updateMatrix", "description": "Given an `m x n` binary matrix `mat`, return the distance of the nearest `0`\nfor each cell.\n\nThe distance between two adjacent cells is `1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 31, 33]}
{"task_num": 547, "task_title": "Number of Provinces", "difficulty": 2, "func_name": "findCircleNum", "description": "There are `n` cities. Some of them are connected, while some are not. If city\n`a` is connected directly with city `b`, and city `b` is connected directly\nwith city `c`, then city `a` is connected indirectly with city `c`.\n\nA province is a group of directly or indirectly connected cities and no other\ncities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if\nthe `ith` city and the `jth` city are directly connected, and\n`isConnected[i][j] = 0` otherwise.\n\nReturn the total number of provinces.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: List[List[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.53}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 25, 27, 28, 33, 45]}
{"task_num": 581, "task_title": "Shortest Unsorted Continuous Subarray", "difficulty": 2, "func_name": "findUnsortedSubarray", "description": "Given an integer array `nums`, you need to find one continuous subarray such\nthat if you only sort this subarray in non-decreasing order, then the whole\narray will be sorted in non-decreasing order.\n\nReturn the shortest such subarray and output its length.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findUnsortedSubarray(self, nums: List[int]) -> int:\n    mini = math.inf\n    maxi = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mini = min(mini, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        maxi = max(maxi, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mini:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < maxi:\n        break\n\n    return 0 if l >= r else r - l + 1\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 21, 27, 29, 33, 37]}
{"task_num": 591, "task_title": "Tag Validator", "difficulty": 3, "func_name": "isValid", "description": "Given a string representing a code snippet, implement a tag validator to parse\nthe code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n1. The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n2. A closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n3. A valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.\n4. A valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.\n5. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n6. A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).\n7. The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`.\n8. `CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\n            return False\n        else:\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 40, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 44, "difficulty": 2, "eg_cov_prob": 0.34}, {"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 49, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.18}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 27, 30, 39, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53]}
{"task_num": 648, "task_title": "Replace Words", "difficulty": 2, "func_name": "replaceWords", "description": "In English, we have a concept called root, which can be followed by some other\nword to form another longer word - let's call this word successor. For\nexample, when the root `\"help\"` is followed by the successor word `\"ful\"`, we\ncan form a new word `\"helpful\"`.\n\nGiven a `dictionary` consisting of many roots and a `sentence` consisting of\nwords separated by spaces, replace all the successors in the sentence with the\nroot forming it. If a successor can be replaced by more than one root, replace\nit with the root that has the shortest length.\n\nReturn the `sentence` after the replacement.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.92}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27, 29]}
{"task_num": 673, "task_title": "Number of Longest Increasing Subsequence", "difficulty": 2, "func_name": "findNumberOfLIS", "description": "Given an integer array `nums`, return the number of longest increasing\nsubsequences.\n\nNotice that the sequence has to be strictly increasing.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findNumberOfLIS(self, nums: List[int]) -> int:\n    ans = 0\n    maxLength = 0\n    length = [1] * len(nums)\n    count = [1] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans\n", "blocks": [{"type": "if", "start": 28, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 23, 24, 25, 29, 30, 32]}
{"task_num": 684, "task_title": "Redundant Connection", "difficulty": 2, "func_name": "findRedundantConnection", "description": "In this problem, a tree is an undirected graph that is connected and has no\ncycles.\n\nYou are given a graph that started as a tree with `n` nodes labeled from `1`\nto `n`, with one additional edge added. The added edge has two different\nvertices chosen from `1` to `n`, and was not an edge that already existed. The\ngraph is represented as an array `edges` of length `n` where `edges[i] = [ai,\nbi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\n\nReturn an edge that can be removed so that the resulting graph is a tree of\n`n` nodes. If there are multiple answers, return the answer that occurs last\nin the input.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 43]}
{"task_num": 685, "task_title": "Redundant Connection II", "difficulty": 3, "func_name": "findRedundantDirectedConnection", "description": "In this problem, a rooted tree is a directed graph such that, there is exactly\none node (the root) for which all other nodes are descendants of this node,\nplus every node has exactly one parent, except for the root node which has no\nparents.\n\nThe given input is a directed graph that started as a rooted tree with `n`\nnodes (with distinct values from `1` to `n`), with one additional directed\nedge added. The added edge has two different vertices chosen from `1` to `n`,\nand was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges`\nis a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and\n`vi`, where `ui` is a parent of child `vi`.\n\nReturn an edge that can be removed so that the resulting graph is a rooted\ntree of `n` nodes. If there are multiple answers, return the answer that\noccurs last in the given 2D-array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        if not findRedundantDirectedConnection(i):\n          return edges[i]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.25}, {"type": "if", "start": 63, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 44, 51, 53, 58, 63, 64]}
{"task_num": 688, "task_title": "Knight Probability in Chessboard", "difficulty": 2, "func_name": "knightProbability", "description": "On an `n x n` chessboard, a knight starts at the cell `(row, column)` and\nattempts to make exactly `k` moves. The rows and columns are 0-indexed, so the\ntop-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.\n\nA chess knight has eight possible moves it can make, as illustrated below.\nEach move is two cells in a cardinal direction, then one cell in an orthogonal\ndirection.\n\nEach time the knight is to move, it chooses one of eight possible moves\nuniformly at random (even if the piece would go off the chessboard) and moves\nthere.\n\nThe knight continues moving until it has made exactly `k` moves or has moved\noff the chessboard.\n\nReturn the probability that the knight remains on the board after it has\nstopped moving.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9}], "target_lines": [25]}
{"task_num": 689, "task_title": "Maximum Sum of 3 Non-Overlapping Subarrays", "difficulty": 3, "func_name": "maxSumOfThreeSubarrays", "description": "Given an integer array `nums` and an integer `k`, find three non-overlapping\nsubarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of\neach interval (0-indexed). If there are multiple answers, return the\nlexicographically smallest one.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n    n = len(nums) - k + 1\n    sums = [0] * n\n    l = [0] * n\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 24, 29, 35, 42, 43, 44]}
{"task_num": 691, "task_title": "Stickers to Spell Word", "difficulty": 3, "func_name": "minStickers", "description": "We are given `n` different types of `stickers`. Each sticker has a lowercase\nEnglish word on it.\n\nYou would like to spell out the given string `target` by cutting individual\nletters from your collection of stickers and rearranging them. You can use\neach sticker more than once if you want, and you have infinite quantities of\neach sticker.\n\nReturn the minimum number of stickers that you need to spell out `target`. If\nthe task is impossible, return `-1`.\n\nNote: In all test cases, all words were chosen randomly from the `1000` most\ncommon US English words, and `target` was chosen as a concatenation of two\nrandom words.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minStickers(self, stickers: List[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 1, "eg_cov_prob": 0.76}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [19, 25, 26]}
{"task_num": 722, "task_title": "Remove Comments", "difficulty": 2, "func_name": "removeComments", "description": "Given a C++ program, remove comments from it. The program source is an array\nof strings `source` where `source[i]` is the `ith` line of the source code.\nThis represents the result of splitting the original source code string by the\nnewline character `'\\n'`.\n\nIn C++, there are two types of comments, line comments, and block comments.\n\n* The string `\"//\"` denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.\n* The string `\"/*\"` denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of `\"*/\"` should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string `\"/*/\"` does not yet end the block comment, as the ending would be overlapping the beginning.\n\nThe first effective comment takes precedence over others.\n\n* For example, if the string `\"//\"` occurs in a block comment, it is ignored.\n* Similarly, if the string `\"/*\"` occurs in a line or block comment, it is also ignored.\n\nIf a certain line of code is empty after removing comments, you must not\noutput that line: each string in the answer list will be non-empty.\n\nThere will be no control characters, single quote, or double quote characters.\n\n* For example, `source = \"string s = \"/* Not a comment. */\";\"` will not be a test case.\n\nAlso, nothing else such as defines or macros will interfere with the comments.\n\nIt is guaranteed that every open block comment will eventually be closed, so\n`\"/*\"` outside of a line or block comment always starts a new comment.\n\nFinally, implicit newline characters can be deleted by block comments. Please\nsee the examples below for details.\n\nAfter removing the comments from the source code, return the source code in\nthe same format.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def removeComments(self, source: List[str]) -> List[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans\n", "blocks": [{"type": "if", "start": 41, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 28, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 31, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 32, "end": 36, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 23, 24, 27, 28, 30, 31, 33, 34, 36, 38, 39, 40, 42, 43]}
{"task_num": 730, "task_title": "Count Different Palindromic Subsequences", "difficulty": 3, "func_name": "countPalindromicSubsequences", "description": "Given a string s, return the number of different non-empty palindromic\nsubsequences in `s`. Since the answer may be very large, return it modulo `109\n+ 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from\nthe string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some\n`i` for which `ai != bi`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + kMod) % kMod\n\n    return dp[0][n - 1]\n", "blocks": [{"type": "if", "start": 23, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 37]}
{"task_num": 735, "task_title": "Asteroid Collision", "difficulty": 2, "func_name": "asteroidCollision", "description": "We are given an array `asteroids` of integers representing asteroids in a row.\n\nFor each asteroid, the absolute value represents its size, and the sign\nrepresents its direction (positive meaning right, negative meaning left). Each\nasteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions. If two asteroids\nmeet, the smaller one will explode. If both are the same size, both will\nexplode. Two asteroids moving in the same direction will never meet.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()\n        else:\n          pass\n\n    return stack\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 18, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.89}, {"type": "else", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 19, 20, 21, 22, 23, 24, 26]}
{"task_num": 743, "task_title": "Network Delay Time", "difficulty": 2, "func_name": "networkDelayTime", "description": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also\ngiven `times`, a list of travel times as directed edges `times[i] = (ui, vi,\nwi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the\ntime it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the minimum time it takes\nfor all the `n` nodes to receive the signal. If it is impossible for all the\n`n` nodes to receive the signal, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1\n", "blocks": [{"type": "if", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [29, 32, 33]}
{"task_num": 770, "task_title": "Basic Calculator IV", "difficulty": 3, "func_name": "basicCalculatorIV", "description": "Given an expression such as `expression = \"e + 8 - a + 5\"` and an evaluation\nmap such as `{\"e\": 1}` (given in terms of `evalvars = [\"e\"]` and `evalints =\n[1]`), return a list of tokens representing the simplified expression, such as\n`[\"-1*a\",\"14\"]`\n\n* An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n* A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n* A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `\"2x\"` or `\"-x\"`.\n\nExpressions are evaluated in the usual order: brackets first, then\nmultiplication, then addition and subtraction.\n\n* For example, `expression = \"1 + 2 * 3\"` has an answer of `[\"7\"]`.\n\nThe format of the output is as follows:\n\n* For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically. \n* For example, we would never write a term like `\"b*a*c\"`, only `\"a*b*c\"`.\n* Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. \n* For example, `\"a*a*b*c\"` has degree `4`.\n* The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n* An example of a well-formatted answer is `[\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]`.\n* Terms (including constant terms) with coefficient `0` are not included. \n* For example, an expression of `\"0\"` has an output of `[]`.\n\nNote: You may assume that the given expression is always valid. All\nintermediate results will be in the range of `[-231, 231 - 1]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  def toList(self) -> List[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0\n    j = 0\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: List[str]) -> List[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: List[str]) -> Poly:\n    polys: List[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 58, "end": 59, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 99, "end": 100, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 66, "end": 68, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 69, "end": 71, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 81, "end": 82, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 90, "end": 93, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 107, "end": 108, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 112, "end": 113, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 129, "end": 137, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 91, "end": 92, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 94, "end": 98, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 114, "end": 117, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 132, "end": 133, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 138, "end": 139, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 140, "end": 141, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 95, "end": 96, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 118, "end": 121, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 122, "end": 123, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 134, "end": 135, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "else", "start": 136, "end": 137, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [14, 16, 38, 42, 48, 57, 59, 67, 68, 70, 71, 82, 91, 92, 93, 95, 96, 97, 98, 100, 108, 113, 115, 116, 117, 119, 120, 121, 123, 130, 131, 132, 133, 134, 135, 137, 139, 141]}
{"task_num": 777, "task_title": "Swap Adjacent in LR String", "difficulty": 2, "func_name": "canTransform", "description": "In a string composed of `'L'`, `'R'`, and `'X'` characters, like\n`\"RXXLRXRXL\"`, a move consists of either replacing one occurrence of `\"XL\"`\nwith `\"LX\"`, or replacing one occurrence of `\"RX\"` with `\"XR\"`. Given the\nstarting string `start` and the ending string `end`, return `True` if and only\nif there exists a sequence of moves to transform one string to the other.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0\n    j = 0\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 27, 29, 31]}
{"task_num": 782, "task_title": "Transform to Chessboard", "difficulty": 3, "func_name": "movesToChessboard", "description": "You are given an `n x n` binary grid `board`. In each move, you can swap any\ntwo rows with each other, or any two columns with each other.\n\nReturn the minimum number of moves to transform the board into a chessboard\nboard. If the task is impossible, return `-1`.\n\nA chessboard board is a board where no `0`'s and no `1`'s are 4-directionally\nadjacent.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def movesToChessboard(self, board: List[List[int]]) -> int:\n    n = len(board)\n\n    for i in range(n):\n      for j in range(n):\n        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:\n          return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n & 1:\n      if rowSwaps & 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps & 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 36, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [18, 24, 26, 32, 33, 34, 35, 37, 38]}
{"task_num": 786, "task_title": "K-th Smallest Prime Fraction", "difficulty": 2, "func_name": "kthSmallestPrimeFraction", "description": "You are given a sorted integer array `arr` containing `1` and prime numbers,\nwhere all the integers of `arr` are unique. You are also given an integer `k`.\n\nFor every `i` and `j` where `0 <= i < j < arr.length`, we consider the\nfraction `arr[i] / arr[j]`.\n\nReturn the `kth` smallest fraction considered. Return your answer as an array\nof integers of size `2`, where `answer[0] == arr[i]` and `answer[1] ==\narr[j]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [29, 31, 32, 35, 37, 39]}
{"task_num": 787, "task_title": "Cheapest Flights Within K Stops", "difficulty": 2, "func_name": "findCheapestPrice", "description": "There are `n` cities connected by some number of flights. You are given an\narray `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there\nis a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return the cheapest\nprice from `src` to `dst` with at most `k` stops. If there is no such route,\nreturn `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:\n    dist=[]\n    for i in range(len(graph)):\n      dist.append([math.inf for _ in range(k + 2)])\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 35, "end": 37, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [31, 33, 36, 37]}
{"task_num": 794, "task_title": "Valid Tic-Tac-Toe State", "difficulty": 2, "func_name": "validTicTacToe", "description": "Given a Tic-Tac-Toe board as a string array `board`, return `true` if and only\nif it is possible to reach this board position during the course of a valid\ntic-tac-toe game.\n\nThe board is a `3 x 3` array that consists of characters `' '`, `'X'`, and\n`'O'`. The `' '` character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n* Players take turns placing characters into empty squares `' '`.\n* The first player always places `'X'` characters, while the second player always places `'O'` characters.\n* `'X'` and `'O'` characters are always placed into empty squares, never filled ones.\n* The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\n* The game also ends if all squares are non-empty.\n* No more moves can be played if the game is over.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def validTicTacToe(self, board: List[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20, 22]}
{"task_num": 805, "task_title": "Split Array With Same Average", "difficulty": 3, "func_name": "splitArraySameAverage", "description": "You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B`\nsuch that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\nNote that for an array `arr`, `average(arr)` is the sum of all the elements of\n`arr` over the length of `arr`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def splitArraySameAverage(self, nums: List[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.54}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.21}], "target_lines": [16, 28]}
{"task_num": 815, "task_title": "Bus Routes", "difficulty": 3, "func_name": "numBusesToDestination", "description": "You are given an array `routes` representing bus routes where `routes[i]` is a\nbus route that the `ith` bus repeats forever.\n\n* For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n\nYou will start at the bus stop `source` (You are not on any bus initially),\nand you want to go to the bus stop `target`. You can travel between bus stops\nby buses only.\n\nReturn the least number of buses you must take to travel from `source` to\n`target`. Return `-1` if it is not possible.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    ans = 0\n    q = collections.deque([source])\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return ans\n            q.append(nextRoute)\n\n    return -1\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 31, 35]}
{"task_num": 838, "task_title": "Push Dominoes", "difficulty": 2, "func_name": "pushDominoes", "description": "There are `n` dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously push some of the dominoes either to the\nleft or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent\ndomino on the left. Similarly, the dominoes falling to the right push their\nadjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays\nstill due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino\nexpends no additional force to a falling or already fallen domino.\n\nYou are given a string `dominoes` representing the initial state where:\n\n* `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,\n* `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and\n* `dominoes[i] = '.'`, if the `ith` domino has not been pushed.\n\nReturn a string representing the final state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)\n", "blocks": [{"type": "if", "start": 18, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.44}], "target_lines": [19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39]}
{"task_num": 845, "task_title": "Longest Mountain in Array", "difficulty": 2, "func_name": "longestMountain", "description": "You may recall that an array `arr` is a mountain array if and only if:\n\n* `arr.length >= 3`\n* There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that: \n* `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n* `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return the length of the longest subarray, which\nis a mountain. Return `0` if there is no mountain subarray.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def longestMountain(self, arr: List[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [32]}
{"task_num": 854, "task_title": "K-Similar Strings", "difficulty": 3, "func_name": "kSimilarity", "description": "Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if\nwe can swap the positions of two letters in `s1` exactly `k` times so that the\nresulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and\n`s2` are `k`-similar.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    ans = 0\n    q = collections.deque([s1])\n    seen = {s1}\n\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return ans\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      ans += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> List[str]:\n    children = []\n    s = list(curr)\n    i = 0\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children\n", "blocks": [{"type": "if", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.9}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.73}], "target_lines": [21, 24, 40, 41, 42]}
{"task_num": 861, "task_title": "Score After Flipping Matrix", "difficulty": 2, "func_name": "matrixScore", "description": "You are given an `m x n` binary matrix `grid`.\n\nA move consists of choosing any row or column and toggling each value in that\nrow or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).\n\nEvery row of the matrix is interpreted as a binary number, and the score of\nthe matrix is the sum of these numbers.\n\nReturn the highest possible score after making any number of moves (including\nzero moves).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matrixScore(self, grid: List[List[int]]) -> int:\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: List[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: List[List[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: List[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.96}, {"type": "if", "start": 18, "end": 19, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [15, 19]}
{"task_num": 866, "task_title": "Prime Palindrome", "difficulty": 2, "func_name": "primePalindrome", "description": "Given an integer n, return the smallest prime palindrome greater than or equal\nto `n`.\n\nAn integer is prime if it has exactly two divisors: `1` and itself. Note that\n`1` is not a prime number.\n\n* For example, `2`, `3`, `5`, `7`, `11`, and `13` are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does\nfrom right to left.\n\n* For example, `101` and `12321` are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the\nrange `[2, 2 * 108]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int):\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      for i in range(2, int(num**0.5 + 1)):\n        if num % i == 0:\n          return False\n      return True\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 27, 29, 31, 33, 35, 42]}
{"task_num": 882, "task_title": "Reachable Nodes In Subdivided Graph", "difficulty": 3, "func_name": "reachableNodes", "description": "You are given an undirected graph (the \"original graph\") with `n` nodes\nlabeled from `0` to `n - 1`. You decide to subdivide each edge in the graph\ninto a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]`\nindicates that there is an edge between nodes `ui` and `vi` in the original\ngraph, and `cnti` is the total number of new nodes that you will subdivide the\nedge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and\n`cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new\nedges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`,\n`[xcnti, vi]`.\n\nIn this new graph, you want to know how many nodes are reachable from the node\n`0`, where a node is reachable if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return the number of nodes that are\nreachable from node `0` in the new graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.87}, {"type": "if", "start": 42, "end": 44, "difficulty": 1, "eg_cov_prob": 0.92}], "target_lines": [37, 39, 43, 44]}
{"task_num": 909, "task_title": "Snakes and Ladders", "difficulty": 2, "func_name": "snakesAndLadders", "description": "You are given an `n x n` integer matrix `board` where the cells are labeled\nfrom `1` to `n2` in a Boustrophedon style starting from the bottom left of the\nboard (i.e. `board[n - 1][0]`) and alternating direction each row.\n\nYou start on square `1` of the board. In each move, starting from square\n`curr`, do the following:\n\n* Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n2)]`. \n* This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.\n* If `next` has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to `next`.\n* The game ends when you reach the square `n2`.\n\nA board square on row `r` and column `c` has a snake or ladder if `board[r][c]\n!= -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1`\nand `n2` do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the\ndestination to a snake or ladder is the start of another snake or ladder, you\ndo not follow the subsequent snake or ladder.\n\n* For example, suppose the board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do not follow the subsequent ladder to `4`.\n\nReturn the least number of moves required to reach the square `n2`. If it is\nnot possible to reach the square, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def snakesAndLadders(self, board: List[List[int]]) -> int:\n    n = len(board)\n    ans = 0\n    q = collections.deque([1])\n    seen = set()\n    A = [0] * (1 + n * n)\n\n    for i in range(n):\n      for j in range(n):\n        if n - i & 1 :\n          A[(n - 1 - i) * n + (j + 1)] = board[i][j]\n        else:\n          A[(n - 1 - i) * n + (n - j)] = board[i][j]\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = A[next] if A[next] > 0 else next\n          if dest == n * n:\n            return ans\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n\n    return -1\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.86}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.92}], "target_lines": [22, 24, 33, 35]}
{"task_num": 913, "task_title": "Cat and Mouse", "difficulty": 3, "func_name": "catMouseGame", "description": "A game on an undirected graph is played by two players, Mouse and Cat, who\nalternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that\n`ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and\ngoes second, and there is a hole at node `0`.\n\nDuring each player's turn, they must travel along one edge of the graph that\nmeets where they are. For example, if the Mouse is at node 1, it must travel\nto any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node `0`).\n\nThen, the game can end in three ways:\n\n* If ever the Cat occupies the same node as the Mouse, the Cat wins.\n* If ever the Mouse reaches the Hole, the Mouse wins.\n* If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n* `1` if the mouse wins the game,\n* `2` if the cat wins the game, or\n* `0` if the game is a draw.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass State(IntEnum):\n  kDraw = 0\n  kMouseWin = 1\n  kCatWin = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: List[List[int]]) -> int:\n    n = len(graph)\n    states = [[[0] * 2 for i in range(n)] for j in range(n)]\n    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]\n    q = collections.deque()\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    for cat in range(1, n):\n      for move in range(2):\n        states[cat][0][move] = int(State.kMouseWin)\n        q.append((cat, 0, move, int(State.kMouseWin)))\n        states[cat][cat][move] = int(State.kCatWin)\n        q.append((cat, cat, move, int(State.kCatWin)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:\n          continue\n        prevMouse = mouse if prevMove else prev\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if prevMove == 0 and state == int(State.kMouseWin) or \\\n                prevMove == 1 and state == int(State.kCatWin):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 1, "eg_cov_prob": 0.77}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 54, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 55, "end": 59, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 57, "end": 59, "difficulty": 1, "eg_cov_prob": 0.81}], "target_lines": [42, 47, 50, 52, 53, 54, 56, 57, 58, 59]}
{"task_num": 923, "task_title": "3Sum With Multiplicity", "difficulty": 2, "func_name": "threeSumMulti", "description": "Given an integer array `arr`, and an integer `target`, return the number of\ntuples `i, j, k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] ==\ntarget`.\n\nAs the answer can be very large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeSumMulti(self, arr: List[int], target: int) -> int:\n    kMod = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % kMod\n\n    return ans % kMod\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.34}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [21, 23, 25, 27]}
{"task_num": 927, "task_title": "Three Equal Parts", "difficulty": 3, "func_name": "threeEqualParts", "description": "You are given an array `arr` which consists of only zeros and ones, divide the\narray into three non-empty parts such that all of these parts represent the\nsame binary value.\n\nIf it is possible, return any `[i, j]` with `i + 1 < j`, such that:\n\n* `arr[0], arr[1], ..., arr[i]` is the first part,\n* `arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and\n* `arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.\n* All three parts have equal binary values.\n\nIf it is not possible, return `[-1, -1]`.\n\nNote that the entire part is used when considering what binary value it\nrepresents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also,\nleading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def threeEqualParts(self, arr: List[int]) -> List[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 31, "end": 35, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 40, "end": 44, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 33, "end": 35, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 42, "end": 44, "difficulty": 2, "eg_cov_prob": 0.39}], "target_lines": [16, 18, 25, 26, 32, 33, 34, 35, 41, 42, 43, 44, 52]}
{"task_num": 935, "task_title": "Knight Dialer", "difficulty": 2, "func_name": "knightDialer", "description": "The chess knight has a unique movement, it may move two squares vertically and\none square horizontally, or two squares horizontally and one square vertically\n(with both forming the shape of an L). The possible movements of chess knight\nare shown in this diagram:\n\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight can only\nstand on a numeric cell (i.e. blue cell).\n\nGiven an integer `n`, return how many distinct phone numbers of length `n` we\ncan dial.\n\nYou are allowed to place the knight on any numeric cell initially and then you\nshould perform `n - 1` jumps to dial a number of length `n`. All jumps should\nbe valid knight jumps.\n\nAs the answer may be very large, return the answer modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def knightDialer(self, n: int) -> int:\n    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    kMod = 1_000_000_007\n\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in dirs:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod\n      dp = newDp\n\n    return sum(map(sum, dp)) % kMod\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 29, 31]}
{"task_num": 939, "task_title": "Minimum Area Rectangle", "difficulty": 2, "func_name": "minAreaRect", "description": "You are given an array of points in the X-Y plane `points` where `points[i] =\n[xi, yi]`.\n\nReturn the minimum area of a rectangle formed from these points, with sides\nparallel to the X and Y axes. If there is not any such rectangle, return `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minAreaRect(self, points: List[List[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.63}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [24, 26]}
{"task_num": 952, "task_title": "Largest Component Size by Common Factor", "difficulty": 3, "func_name": "largestComponentSize", "description": "You are given an integer array of unique positive integers `nums`. Consider\nthe following graph:\n\n* There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,\n* There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn the size of the largest connected component in the graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: List[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, int(math.sqrt(num) + 1)):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31, 44, 45]}
{"task_num": 963, "task_title": "Minimum Area Rectangle II", "difficulty": 2, "func_name": "minAreaFreeRect", "description": "You are given an array of points in the X-Y plane `points` where `points[i] =\n[xi, yi]`.\n\nReturn the minimum area of any rectangle formed from these points, with sides\nnot necessarily parallel to the X and Y axes. If there is not any such\nrectangle, return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom math import sqrt\n\nclass Solution:\n  def minAreaFreeRect(self, points: List[List[int]]) -> float:\n    ans = math.inf\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else sqrt(ans)\n", "blocks": [{"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [29, 30, 31]}
{"task_num": 990, "task_title": "Satisfiability of Equality Equations", "difficulty": 2, "func_name": "equationsPossible", "description": "You are given an array of strings `equations` that represent relationships\nbetween variables where each string `equations[i]` is of length `4` and takes\none of two different forms: `\"xi==yi\"` or `\"xi!=yi\"`.Here, `xi` and `yi` are\nlowercase letters (not necessarily different) that represent one-letter\nvariable names.\n\nReturn `true` if it is possible to assign integers to variable names so as to\nsatisfy all the given equations, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: List[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))\n\n    for x, op, _, y in equations:\n      if op == '!':\n        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):\n          return False\n    return True\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [20, 30, 34, 35]}
{"task_num": 999, "task_title": "Available Captures for Rook", "difficulty": 1, "func_name": "numRookCaptures", "description": "On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some\nnumber of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east,\nsouth, or west), then moves in that direction until it chooses to stop,\nreaches the edge of the board, captures a black pawn, or is blocked by a white\nbishop. A rook is considered attacking a pawn if the rook can capture the pawn\non the rook's turn. The number of available captures for the white rook is the\nnumber of pawns that the rook is attacking.\n\nReturn the number of available captures for the white rook.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numRookCaptures(self, board: List[List[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.82}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 19, 26, 28]}
{"task_num": 1001, "task_title": "Grid Illumination", "difficulty": 3, "func_name": "gridIllumination", "description": "There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp\nthat is initially turned off.\n\nYou are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi,\ncoli]` indicates that the lamp at `grid[rowi][coli]` is turned on. Even if the\nsame lamp is listed more than once, it is turned on.\n\nWhen a lamp is turned on, it illuminates its cell and all other cells in the\nsame row, column, or diagonal.\n\nYou are also given another 2D array `queries`, where `queries[j] = [rowj,\ncolj]`. For the `jth` query, determine whether `grid[rowj][colj]` is\nilluminated or not. After answering the `jth` query, turn off the lamp at\n`grid[rowj][colj]` and its 8 adjacent lamps if they exist. A lamp is adjacent\nif its cell shares either a side or corner with `grid[rowj][colj]`.\n\nReturn an array of integers `ans`, where `ans[j]` should be `1` if the cell in\nthe `jth` query was illuminated, or `0` if the lamp was not.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 24, 25, 26, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40]}
{"task_num": 1093, "task_title": "Statistics from a Large Sample", "difficulty": 2, "func_name": "sampleStats", "description": "You are given a large sample of integers in the range `[0, 255]`. Since the\nsample is so large, it is represented by an array `count` where `count[k]` is\nthe number of times that `k` appears in the sample.\n\nCalculate the following statistics:\n\n* `minimum`: The minimum element in the sample.\n* `maximum`: The maximum element in the sample.\n* `mean`: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.\n* `median`: \n* If the sample has an odd number of elements, then the `median` is the middle element once the sample is sorted.\n* If the sample has an even number of elements, then the `median` is the average of the two middle elements once the sample is sorted.\n* `mode`: The number that appears the most in the sample. It is guaranteed to be unique.\n\nReturn the statistics of the sample as an array of floating-point numbers\n`[minimum, maximum, mean, median, mode]`. Answers within `10-5` of the actual\nanswer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def sampleStats(self, count: List[int]) -> List[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]\n", "blocks": [{"type": "if", "start": 23, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 32, 33]}
{"task_num": 1129, "task_title": "Shortest Path with Alternating Colors", "difficulty": 2, "func_name": "shortestAlternatingPaths", "description": "You are given an integer `n`, the number of nodes in a directed graph where\nthe nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this\ngraph, and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n* `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and\n* `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n`, where each `answer[x]` is the length\nof the shortest path from node `0` to node `x` such that the edge colors\nalternate along the path, or `-1` if such a path does not exist.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Color(Enum):\n  kInit = 0\n  kRed = 1\n  kBlue = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]\n    q = collections.deque([(0, Color.kInit)])\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.kRed))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.kBlue))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)\n      step += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [37, 40]}
{"task_num": 1139, "task_title": "Largest 1-Bordered Square", "difficulty": 2, "func_name": "largest1BorderedSquare", "description": "Given a 2D `grid` of `0`s and `1`s, return the number of elements in the\nlargest square subgrid that has all `1`s on its border, or `0` if such a\nsubgrid doesn't exist in the `grid`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    leftOnes = [[0] * n for _ in range(m)]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          if j==0:\n            leftOnes[i][j]=1\n          else:\n            leftOnes[i][j]=1+leftOnes[i][j-1]\n          if i==0:\n            topOnes[i][j]=1\n          else:\n            topOnes[i][j]=1+topOnes[i-1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0\n", "blocks": [{"type": "if", "start": 21, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 36, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 25, 26, 27, 29, 37]}
{"task_num": 1162, "task_title": "As Far from Land as Possible", "difficulty": 2, "func_name": "maxDistance", "description": "Given an `n x n` `grid` containing only values `0` and `1`, where `0`\nrepresents water and `1` represents land, find a water cell such that its\ndistance to the nearest land cell is maximized, and return the distance. If no\nland or water exists in the grid, return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance\nbetween two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxDistance(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2\n      d += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.02}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 41, "end": 42, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [22, 24, 27, 40, 42]}
{"task_num": 1202, "task_title": "Smallest String With Swaps", "difficulty": 2, "func_name": "smallestStringWithSwaps", "description": "You are given a string `s`, and an array of pairs of indices in the string\n`pairs` where `pairs[i] = [a, b]` indicates 2 indices(0-indexed) of the\nstring.\n\nYou can swap the characters at any pair of indices in the given `pairs` any\nnumber of times.\n\nReturn the lexicographically smallest string that `s` can be changed to after\nusing the swaps.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    ans = ''\n    uf = UnionFind(len(s))\n    map = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      map[uf.find(i)].append(c)\n\n    for key in map.keys():\n      map[key].sort(reverse=True)\n\n    for i in range(len(s)):\n      ans += map[uf.find(i)].pop()\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31]}
{"task_num": 1210, "task_title": "Minimum Moves to Reach Target with Rotations", "difficulty": 3, "func_name": "minimumMoves", "description": "In an `n*n` grid, there is a snake that spans 2 cells and starts moving from\nthe top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells\nrepresented by zeros and blocked cells represented by ones. The snake wants to\nreach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.\n\nIn one move the snake can:\n\n* Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n* Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n* Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.  \n\n* Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.  \n\nReturn the minimum number of moves to reach the target.\n\nIf there is no way to reach the target, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import IntEnum\n\n\nclass Pos(IntEnum):\n  kHorizontal = 0\n  kVertical = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\n    seen = {(0, 0, Pos.kHorizontal)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kHorizontal:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.kVertical:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kHorizontal and x + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return pos == Pos.kVertical and y + 1 < n and \\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1\n", "blocks": [{"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.44}, {"type": "if", "start": 48, "end": 49, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 50, "end": 52, "difficulty": 1, "eg_cov_prob": 0.62}, {"type": "if", "start": 53, "end": 55, "difficulty": 1, "eg_cov_prob": 0.44}, {"type": "if", "start": 57, "end": 59, "difficulty": 1, "eg_cov_prob": 0.44}], "target_lines": [29, 34, 49, 51, 52, 54, 55, 58, 59]}
{"task_num": 1253, "task_title": "Reconstruct a 2-Row Binary Matrix", "difficulty": 2, "func_name": "reconstructMatrix", "description": "Given the following details of a matrix with `n` columns and `2` rows :\n\n* The matrix is a binary matrix, which means each element in the matrix can be `0` or `1`.\n* The sum of elements of the 0-th(upper) row is given as `upper`.\n* The sum of elements of the 1-st(lower) row is given as `lower`.\n* The sum of elements in the i-th column(0-indexed) is `colsum[i]`, where `colsum` is given as an integer array with length `n`.\n\nYour task is to reconstruct the matrix with `upper`, `lower` and `colsum`.\n\nReturn it as a 2-D integer array.\n\nIf there are more than one valid solution, any of them will be accepted.\n\nIf no valid solution exists, return an empty 2-D array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 31, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 16, 22, 23, 24, 25, 29, 30, 31, 33, 34]}
{"task_num": 1254, "task_title": "Number of Closed Islands", "difficulty": 2, "func_name": "closedIsland", "description": "Given a 2D `grid` consists of `0s` (land) and `1s` (water). An island is a\nmaximal 4-directionally connected group of `0s` and a closed island is an\nisland totally (all left, top, right, bottom) surrounded by `1s.`\n\nReturn the number of closed islands.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closedIsland(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 20, 31, 32, 39, 40]}
{"task_num": 1263, "task_title": "Minimum Moves to Move a Box to Their Target Location", "difficulty": 3, "func_name": "minPushBox", "description": "A storekeeper is a game in which the player pushes boxes around in a warehouse\ntrying to get them to target locations.\n\nThe game is represented by an `m x n` grid of characters `grid` where each\nelement is a wall, floor, or box.\n\nYour task is to move the box `'B'` to the target position `'T'` under the\nfollowing rules:\n\n* The character `'S'` represents the player. The player can move up, down, left, right in `grid` if it is a floor (empty cell).\n* The character `'.'` represents the floor which means a free cell to walk.\n* The character `'#'` represents the wall which means an obstacle (impossible to walk there).\n* There is only one box `'B'` and one target cell `'T'` in the `grid`.\n* The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\n* The player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is\nno way to reach the target, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom collections import deque\n\nclass Solution:\n  def minPushBox(self, grid: List[List[str]]) -> int:\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == \"T\":\n          target = (i,j)\n        if grid[i][j] == \"B\":\n          box = (i,j)\n        if grid[i][j] == \"S\":\n          person = (i,j)\n\n    def valid(x,y):\n      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'\n\n    def check(curr,dest,box):\n      que = deque([curr])\n      v = set()\n      while que:\n        pos = que.popleft()\n        if pos == dest: \n          return True\n        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]\n        for x,y in new_pos:\n          if valid(x,y) and (x,y) not in v and (x,y)!=box:\n            v.add((x,y))\n            que.append((x,y))\n      return False\n\n    q = deque([(0,box,person)])\n    vis = {box+person}\n    while q :\n      dist, box, person = q.popleft()\n      if box == target:\n        return dist\n\n      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]\n      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]\n\n      for new_box,new_person in zip(b_coord,p_coord): \n        if valid(*new_box) and new_box+box not in vis:\n          if valid(*new_person) and check(person,new_person,box):\n            vis.add(new_box+box)\n            q.append((dist+1,new_box,box))\n\n    return -1\n", "blocks": [{"type": "if", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.16}, {"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.35}, {"type": "if", "start": 51, "end": 54, "difficulty": 1, "eg_cov_prob": 0.82}, {"type": "if", "start": 35, "end": 37, "difficulty": 2, "eg_cov_prob": 0.39}, {"type": "if", "start": 52, "end": 54, "difficulty": 2, "eg_cov_prob": 0.35}], "target_lines": [17, 19, 21, 32, 36, 37, 45, 52, 53, 54]}
{"task_num": 1267, "task_title": "Count Servers that Communicate", "difficulty": 2, "func_name": "countServers", "description": "You are given a map of a server center, represented as a `m * n` integer\nmatrix `grid`, where 1 means that on that cell there is a server and 0 means\nthat it is no server. Two servers are said to communicate if they are on the\nsame row or on the same column.  \n\nReturn the number of servers that communicate with any other server.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countServers(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 28]}
{"task_num": 1284, "task_title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix", "difficulty": 3, "func_name": "minFlips", "description": "Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and\nflip it and all the four neighbors of it if they exist (Flip is changing `1`\nto `0` and `0` to `1`). A pair of cells are called neighbors if they share one\nedge.\n\nReturn the minimum number of steps required to convert `mat` to a zero matrix\nor `-1` if you cannot.\n\nA binary matrix is a matrix with all cells equal to `0` or `1` only.\n\nA zero matrix is a matrix with all cells equal to `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minFlips(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            for dx, dy in dirs:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 50, "end": 51, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.64}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.61}, {"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.91}], "target_lines": [17, 35, 38, 40, 51]}
{"task_num": 1293, "task_title": "Shortest Path in a Grid with Obstacles Elimination", "difficulty": 3, "func_name": "shortestPath", "description": "You are given an `m x n` integer matrix `grid` where each cell is either `0`\n(empty) or `1` (obstacle). You can move up, down, left, or right from and to\nan empty cell in one step.\n\nReturn the minimum number of steps to walk from the upper left corner `(0, 0)`\nto the lower right corner `(m - 1, n - 1)` given that you can eliminate at\nmost `k` obstacles. If it is not possible to find such walk return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestPath(self, grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    steps = 0\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    while q:\n      steps += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for l in range(4):\n          x = i + dirs[l][0]\n          y = j + dirs[l][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return steps\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.01}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.13}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [16, 31, 33, 35, 38]}
{"task_num": 1301, "task_title": "Number of Paths with Max Score", "difficulty": 3, "func_name": "pathsWithMaxScore", "description": "You are given a square `board` of characters. You can move on the board\nstarting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The\nrest of the squares are labeled either with a numeric character `1, 2, ..., 9`\nor with an obstacle `'X'`. In one move you can go up, left or up-left\n(diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric\ncharacters you can collect, and the second is the number of such paths that\nyou can take to get that maximum sum, taken modulo `10^9 + 7`.\n\nIn case there is no path, return `[0, 0]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def pathsWithMaxScore(self, board: List[str]) -> List[int]:\n    kMod = 1_000_000_007\n    n = len(board)\n    dirs = ((0, 1), (1, 0), (1, 1))\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= kMod\n\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= kMod\n\n    return [dp[0][0], count[0][0]]\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 31, 32, 34, 35, 38, 39]}
{"task_num": 1334, "task_title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance", "difficulty": 2, "func_name": "findTheCity", "description": "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where\n`edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted\nedge between cities `fromi` and `toi`, and given the integer\n`distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through\nsome path and whose distance is at most `distanceThreshold`, If there are\nmultiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities i and j is equal to the\nsum of the edges' weights along that path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n", "blocks": [{"type": "if", "start": 19, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 21]}
{"task_num": 1340, "task_title": "Jump Game V", "difficulty": 3, "func_name": "maxJumps", "description": "Given an array of integers `arr` and an integer `d`. In one step you can jump\nfrom index `i` to index:\n\n* `i + x` where: `i + x < arr.length` and ` 0 < x <= d`.\n* `i - x` where: `i - x >= 0` and ` 0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] >\narr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More\nformally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return the maximum\nnumber of indices you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    n = len(arr)\n    dp = [1] * n\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [24, 26]}
{"task_num": 1345, "task_title": "Jump Game IV", "difficulty": 3, "func_name": "minJumps", "description": "Given an array of integers `arr`, you are initially positioned at the first\nindex of the array.\n\nIn one step you can jump from index `i` to index:\n\n* `i + 1` where: `i + 1 < arr.length`.\n* `i - 1` where: `i - 1 >= 0`.\n* `j` where: `arr[i] == arr[j]` and `i != j`.\n\nReturn the minimum number of steps to reach the last index of the array.\n\nNotice that you can not jump outside of the array at any time.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 30, 32, 35]}
{"task_num": 1377, "task_title": "Frog Position After T Seconds", "difficulty": 3, "func_name": "frogPosition", "description": "Given an undirected tree consisting of `n` vertices numbered from `1` to `n`.\nA frog starts jumping from vertex 1. In one second, the frog jumps from its\ncurrent vertex to another unvisited vertex if they are directly connected. The\nfrog can not jump back to a visited vertex. In case the frog can jump to\nseveral vertices, it jumps randomly to one of them with the same probability.\nOtherwise, when the frog can not jump to any unvisited vertex, it jumps\nforever on the same vertex.\n\nThe edges of the undirected tree are given in the array `edges`, where\n`edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai`\nand `bi`.\n\nReturn the probability that after `t` seconds the frog is on the vertex\n`target`. Answers within `10-5` of the actual answer will be accepted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.96}], "target_lines": [31, 36]}
{"task_num": 1417, "task_title": "Reformat The String", "difficulty": 1, "func_name": "reformat", "description": "You are given an alphanumeric string `s`. (Alphanumeric string is a string\nconsisting of lowercase English letters and digits).\n\nYou have to find a permutation of the string where no letter is followed by\nanother letter and no digit is followed by another digit. That is, no two\nadjacent characters have the same type.\n\nReturn the reformatted string or return an empty string if it is impossible to\nreformat the string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def reformat(self, s: str) -> str:\n    A=[]\n    for c in s:\n      if c.isalpha():\n        A.append(c)\n    B=[]\n    for c in s:\n      if c.isdigit():\n        B.append(c)\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 15, "end": 16, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [16, 20, 23, 25, 34]}
{"task_num": 1462, "task_title": "Course Schedule IV", "difficulty": 2, "func_name": "checkIfPrerequisite", "description": "There are a total of `numCourses` courses you have to take, labeled from `0`\nto `numCourses - 1`. You are given an array `prerequisites` where\n`prerequisites[i] = [ai, bi]` indicates that you must take course `ai` first\nif you want to take course `bi`.\n\n* For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`.\n\nPrerequisites can also be indirect. If course `a` is a prerequisite of course\n`b`, and course `b` is a prerequisite of course `c`, then course `a` is a\nprerequisite of course `c`.\n\nYou are also given an array `queries` where `queries[j] = [uj, vj]`. For the\n`jth` query, you should answer whether course `uj` is a prerequisite of course\n`vj` or not.\n\nReturn a boolean array `answer`, where `answer[j]` is the answer to the `jth`\nquery.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(numCourses)]\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27]}
{"task_num": 1489, "task_title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree", "difficulty": 3, "func_name": "findCriticalAndPseudoCriticalEdges", "description": "Given a weighted undirected connected graph with `n` vertices numbered from\n`0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]`\nrepresents a bidirectional and weighted edge between nodes `ai` and `bi`. A\nminimum spanning tree (MST) is a subset of the graph's edges that connects all\nvertices without cycles and with the minimum possible total edge weight.\n\nFind all the critical and pseudo-critical edges in the given graph's minimum\nspanning tree (MST). An MST edge whose deletion from the graph would cause the\nMST weight to increase is called a critical edge. On the other hand, a pseudo-\ncritical edge is that which can appear in some MSTs but not all.\n\nNote that you can return the indices of the edges in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Union\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.93}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 1, "eg_cov_prob": 0.78}, {"type": "if", "start": 71, "end": 72, "difficulty": 2, "eg_cov_prob": 0.33}, {"type": "if", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 73, "end": 74, "difficulty": 1, "eg_cov_prob": 0.69}], "target_lines": [20, 22, 24, 26, 27, 31, 50, 51, 55, 57, 63, 72, 74]}
{"task_num": 1573, "task_title": "Number of Ways to Split a String", "difficulty": 2, "func_name": "numWays", "description": "Given a binary string `s`, you can split `s` into 3 non-empty strings `s1`,\n`s2`, and `s3` where `s1 + s2 + s3 = s`.\n\nReturn the number of ways `s` can be split such that the number of ones is the\nsame in `s1`, `s2`, and `s3`. Since the answer may be too large, return it\nmodulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numWays(self, s: str) -> int:\n    kMod = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % kMod\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % kMod\n", "blocks": [{"type": "if", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.73}, {"type": "if", "start": 17, "end": 19, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 30, "end": 31, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.27}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.27}], "target_lines": [16, 18, 19, 29, 31, 33, 35, 37]}
{"task_num": 1574, "task_title": "Shortest Subarray to be Removed to Make Array Sorted", "difficulty": 2, "func_name": "findLengthOfShortestSubarray", "description": "Given an integer array `arr`, remove a subarray (can be empty) from `arr` such\nthat the remaining elements in `arr` are non-decreasing.\n\nReturn the length of the shortest subarray to remove.\n\nA subarray is a contiguous subsequence of the array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    ans = min(n - 1 - l, r)\n\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "else", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.88}], "target_lines": [27, 29]}
{"task_num": 1579, "task_title": "Remove Max Number of Edges to Keep Graph Fully Traversable", "difficulty": 3, "func_name": "maxNumEdgesToRemove", "description": "Alice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n* Type 1: Can be traversed by Alice only.\n* Type 2: Can be traversed by Bob only.\n* Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei, ui, vi]` represents a\nbidirectional edge of type `typei` between nodes `ui` and `vi`, find the\nmaximum number of edges you can remove so that after removing the edges, the\ngraph can still be fully traversed by both Alice and Bob. The graph is fully\ntraversed by Alice and Bob if starting from any node, they can reach all other\nnodes.\n\nReturn the maximum number of edges you can remove, or return `-1` if Alice and\nBob cannot fully traverse the graph.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    for type, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type == 3:\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type == 2:\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    if alice.count == 1 and bob.count == 1:\n        return len(edges) - requiredEdges\n    else:\n        return -1\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 1, "eg_cov_prob": 0.72}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 57, "end": 58, "difficulty": 2, "eg_cov_prob": 0.05}, {"type": "else", "start": 59, "end": 60, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "else", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 1, "eg_cov_prob": 0.95}, {"type": "if", "start": 54, "end": 55, "difficulty": 1, "eg_cov_prob": 0.95}], "target_lines": [21, 23, 25, 27, 28, 34, 48, 49, 51, 52, 53, 55, 58, 60]}
{"task_num": 1582, "task_title": "Special Positions in a Binary Matrix", "difficulty": 1, "func_name": "numSpecial", "description": "Given an `m x n` binary matrix `mat`, return the number of special positions\nin `mat`.\n\nA position `(i, j)` is called special if `mat[i][j] == 1` and all other\nelements in row `i` and column `j` are `0` (rows and columns are 0-indexed).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numSpecial(self, mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 28]}
{"task_num": 1583, "task_title": "Count Unhappy Friends", "difficulty": 2, "func_name": "unhappyFriends", "description": "You are given a list of `preferences` for `n` friends, where `n` is always\neven.\n\nFor each person `i`, `preferences[i]` contains a list of friends sorted in the\norder of preference. In other words, a friend earlier in the list is more\npreferred than a friend later in the list. Friends in each list are denoted by\nintegers from `0` to `n-1`.\n\nAll the friends are divided into pairs. The pairings are given in a list\n`pairs`, where `pairs[i] = [xi, yi]` denotes `xi` is paired with `yi` and `yi`\nis paired with `xi`.\n\nHowever, this pairing may cause some of the friends to be unhappy. A friend\n`x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is\npaired with `v` but:\n\n* `x` prefers `u` over `y`, and\n* `u` prefers `x` over `v`.\n\nReturn the number of unhappy friends.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 31, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [30, 31]}
{"task_num": 1591, "task_title": "Strange Printer II", "difficulty": 3, "func_name": "isPrintable", "description": "There is a strange printer with the following two special requirements:\n\n* On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n* Once the printer has used a color for the above operation, the same color cannot be used again.\n\nYou are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is\nthe color in the position `(row, col)` of the grid.\n\nReturn `true` if it is possible to print the matrix `targetGrid`, otherwise,\nreturn `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: List[List[int]]) -> bool:\n    kMaxColor = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    graph = [set() for _ in range(kMaxColor + 1)]\n\n    for color in range(1, kMaxColor + 1):\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.kInit] * (kMaxColor + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.kVisiting:\n        return True\n      if states[u] == State.kVisited:\n        return False\n\n      states[u] = State.kVisiting\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.kVisited\n\n      return False\n\n    for i in range(1, kMaxColor + 1):\n      if hasCycle(i):\n        return False\n    return True\n", "blocks": [{"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [36, 37, 38, 39, 44, 50, 52, 56, 63]}
{"task_num": 1604, "task_title": "Alert Using Same Key-Card Three or More Times in a One Hour Period", "difficulty": 2, "func_name": "alertNames", "description": "LeetCode company workers use key-cards to unlock office doors. Each time a\nworker uses their key-card, the security system saves the worker's name and\nthe time when it was used. The system emits an alert if any worker uses the\nkey-card three or more times in a one-hour period.\n\nYou are given a list of strings `keyName` and `keyTime` where `[keyName[i],\nkeyTime[i]]` corresponds to a person's name and the time when their key-card\nwas used in a single day.\n\nAccess times are given in the 24-hour time format \"HH:MM\", such as `\"23:51\"`\nand `\"09:49\"`.\n\nReturn a list of unique worker names who received an alert for frequent\nkeycard use. Sort the names in ascending order alphabetically.\n\nNotice that `\"10:00\"` \\- `\"11:00\"` is considered to be within a one-hour\nperiod, while `\"22:51\"` \\- `\"23:52\"` is not considered to be within a one-hour\nperiod.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    res=[]\n    for name, minutes in nameToMinutes.items():\n      if self._hasAlert(minutes):\n        res.append(name)\n    return sorted(res)\n\n  def _hasAlert(self, minutes: List[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.84}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.98}], "target_lines": [22, 27, 31]}
{"task_num": 1615, "task_title": "Maximal Network Rank", "difficulty": 2, "func_name": "maximalNetworkRank", "description": "There is an infrastructure of `n` cities with some number of `roads`\nconnecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a\nbidirectional road between cities `ai` and `bi`.\n\nThe network rank of two different cities is defined as the total number of\ndirectly connected roads to either city. If a road is directly connected to\nboth cities, it is only counted once.\n\nThe maximal network rank of the infrastructure is the maximum network rank of\nall pairs of different cities.\n\nGiven the integer `n` and the array `roads`, return the maximal network rank\nof the entire infrastructure.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount\n", "blocks": [{"type": "if", "start": 36, "end": 38, "difficulty": 1, "eg_cov_prob": 0.48}, {"type": "else", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.52}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 0.99}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 1, "eg_cov_prob": 0.79}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.98}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.48}], "target_lines": [23, 24, 26, 32, 34, 37, 38, 40, 41, 42, 48]}
{"task_num": 1616, "task_title": "Split Two Strings to Make Palindrome", "difficulty": 2, "func_name": "checkPalindromeFormation", "description": "You are given two strings `a` and `b` of the same length. Choose an index and\nsplit both strings at the same index, splitting `a` into two strings:\n`aprefix` and `asuffix` where `a = aprefix + asuffix`, and splitting `b` into\ntwo strings: `bprefix` and `bsuffix` where `b = bprefix + bsuffix`. Check if\n`aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome.\n\nWhen you split a string `s` into `sprefix` and `ssuffix`, either `ssuffix` or\n`sprefix` is allowed to be empty. For example, if `s = \"abc\"`, then `\"\" +\n\"abc\"`, `\"a\" + \"bc\"`, `\"ab\" + \"c\"` , and `\"abc\" + \"\"` are valid splits.\n\nReturn `true` if it is possible to form a palindrome string, otherwise return\n`false`.\n\nNotice that `x + y` denotes the concatenation of strings `x` and `y`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27]}
{"task_num": 1617, "task_title": "Count Subtrees With Max Distance Between Cities", "difficulty": 3, "func_name": "countSubgraphsForEachDiameter", "description": "There are `n` cities numbered from `1` to `n`. You are given an array `edges`\nof size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge\nbetween cities `ui` and `vi`. There exists a unique path between each pair of\ncities. In other words, the cities form a tree.\n\nA subtree is a subset of cities where every city is reachable from every other\ncity in the subset, where the path between each pair passes through only the\ncities from the subset. Two subtrees are different if there is a city in one\nsubtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the\nmaximum distance between any two cities in the subtree is equal to `d`.\n\nReturn an array of size `n-1` where the `dth` element (1-indexed) is the\nnumber of subtrees in which the maximum distance between any two cities is\nequal to `d`.\n\nNotice that the distance between the two cities is the number of edges in the\npath between them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:\n          continue\n        if dist[u][v] == 1:\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    if edgeCount == cityCount - 1:\n      return maxDist\n    else:\n      return 0\n", "blocks": [{"type": "if", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 47, 51, 53, 57, 59]}
{"task_num": 1627, "task_title": "Graph Connectivity With Threshold", "difficulty": 3, "func_name": "areConnected", "description": "We have `n` cities labeled from `1` to `n`. Two different cities with labels\n`x` and `y` are directly connected by a bidirectional road if and only if `x`\nand `y` share a common divisor strictly greater than some `threshold`. More\nformally, cities with labels `x` and `y` have a road between them if there\nexists an integer `z` such that all of the following are true:\n\n* `x % z == 0`,\n* `y % z == 0`, and\n* `z > threshold`.\n\nGiven the two integers, `n` and `threshold`, and an array of `queries`, you\nmust determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are\nconnected directly or indirectly. (i.e. there is some path between them).\n\nReturn an array `answer`, where `answer.length == queries.length` and\n`answer[i]` is `true` if for the `ith` query, there is a path between `ai` and\n`bi`, or `answer[i]` is `false` if there is no path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.33}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.63}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.46}, {"type": "else", "start": 25, "end": 27, "difficulty": 1, "eg_cov_prob": 0.63}], "target_lines": [20, 22, 24, 26, 27, 32]}
{"task_num": 1631, "task_title": "Path With Minimum Effort", "difficulty": 2, "func_name": "minimumEffortPath", "description": "You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D\narray of size `rows x columns`, where `heights[row][col]` represents the\nheight of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`,\nand you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e.,\n0-indexed). You can move up, down, left, or right, and you wish to find a\nroute that requires the minimum effort.\n\nA route's effort is the maximum absolute difference in heights between two\nconsecutive cells of the route.\n\nReturn the minimum effort required to travel from the top-left cell to the\nbottom-right cell.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumEffortPath(self, heights: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [25, 31, 33, 37, 38]}
{"task_num": 1632, "task_title": "Rank Transform of a Matrix", "difficulty": 3, "func_name": "matrixRankTransform", "description": "Given an `m x n` `matrix`, return a new matrix `answer` where\n`answer[row][col]` is the rank of `matrix[row][col]`.\n\nThe rank is an integer that represents how large an element is compared to\nother elements. It is calculated using the following rules:\n\n* The rank is an integer starting from `1`.\n* If two elements `p` and `q` are in the same row or column, then: \n* If `p < q` then `rank(p) < rank(q)`\n* If `p == q` then `rank(p) == rank(q)`\n* If `p > q` then `rank(p) > rank(q)`\n* The rank should be as small as possible.\n\nThe test cases are generated so that `answer` is unique under the given rules.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> Dict[int, List[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    valToGrids = collections.defaultdict(list)\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 31]}
{"task_num": 1654, "task_title": "Minimum Jumps to Reach Home", "difficulty": 2, "func_name": "minimumJumps", "description": "A certain bug's home is on the x-axis at position `x`. Help them get there\nfrom position `0`.\n\nThe bug jumps according to the following rules:\n\n* It can jump exactly `a` positions forward (to the right).\n* It can jump exactly `b` positions backward (to the left).\n* It cannot jump backward twice in a row.\n* It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward beyond its home, but it cannot jump to positions\nnumbered with negative integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the\nbug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and\n`x`, return the minimum number of jumps needed for the bug to reach its home.\nIf there is no possible sequence of jumps that lands the bug on position `x`,\nreturn `-1.`\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass Direction(Enum):\n  kForward = 0\n  kBackward = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    q = collections.deque([(Direction.kForward, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.kForward, forward))\n        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.kBackward, backward))\n      ans += 1\n\n    return -1\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.18}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 1, "eg_cov_prob": 0.79}], "target_lines": [32, 36, 37, 39, 40]}
{"task_num": 1655, "task_title": "Distribute Repeating Integers", "difficulty": 3, "func_name": "canDistribute", "description": "You are given an array of `n` integers, `nums`, where there are at most `50`\nunique values in the array. You are also given an array of `m` customer order\nquantities, `quantity`, where `quantity[i]` is the amount of integers the\n`ith` customer ordered. Determine if it is possible to distribute `nums` such\nthat:\n\n* The `ith` customer gets exactly `quantity[i]` integers,\n* The integers the `ith` customer gets are all equal, and\n* Every customer is satisfied.\n\nReturn `true` if it is possible to distribute `nums` according to the above\nconditions.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:\n    res=[]\n    for i, q in enumerate(quantity):\n      if mask >> i & 1:\n        res.append(q)\n    return sum(res)\n", "blocks": [{"type": "if", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.13}], "target_lines": [28, 39, 46]}
{"task_num": 1681, "task_title": "Minimum Incompatibility", "difficulty": 3, "func_name": "minimumIncompatibility", "description": "You are given an integer array `nums`\u200b\u200b\u200b and an integer `k`. You are asked to\ndistribute this array into `k` subsets of equal size such that there are no\ntwo equal elements in the same subset.\n\nA subset's incompatibility is the difference between the maximum and minimum\nelements in that array.\n\nReturn the minimum possible sum of incompatibilities of the `k` subsets after\ndistributing the array optimally, or return `-1` if it is not possible.\n\nA subset is a group integers that appear in the array with no particular\norder.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def __init__(self):\n    self.kMaxNum = 16\n\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\n    kMaxCompatibility = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    dp = [kMaxCompatibility] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:\n          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    if dp[-1] != kMaxCompatibility:\n      return dp[-1]\n    else:\n      return -1\n\n  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: List[int], mask: int) -> int:\n    mini = self.kMaxNum\n    maxi = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        maxi = max(maxi, num)\n        mini = min(mini, num)\n    return maxi - mini\n", "blocks": [{"type": "if", "start": 34, "end": 35, "difficulty": 1, "eg_cov_prob": 0.91}, {"type": "else", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.09}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.36}, {"type": "if", "start": 43, "end": 44, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 58, "end": 60, "difficulty": 1, "eg_cov_prob": 0.97}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.97}], "target_lines": [27, 31, 35, 37, 44, 51, 59, 60]}
{"task_num": 1687, "task_title": "Delivering Boxes from Storage to Ports", "difficulty": 3, "func_name": "boxDelivering", "description": "You have the task of delivering some boxes from storage to their ports using\nonly one ship. However, this ship has a limit on the number of boxes and the\ntotal weight that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u200b\u200bi\u200b, weighti]`, and\nthree integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n* `ports\u200b\u200bi` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n* `portsCount` is the number of ports.\n* `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered in the order they are given. The ship will\nfollow these steps:\n\n* The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n* For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.\n* The ship then makes a return trip to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn the minimum number of trips the ship needs to make to deliver all boxes\nto their respective ports.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\n    n = len(boxes)\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28]}
{"task_num": 1705, "task_title": "Maximum Number of Eaten Apples", "difficulty": 2, "func_name": "eatenApples", "description": "There is a special kind of apple tree that grows apples every day for `n`\ndays. On the `ith` day, the tree grows `apples[i]` apples that will rot after\n`days[i]` days, that is on day `i + days[i]` the apples will be rotten and\ncannot be eaten. On some days, the apple tree does not grow any apples, which\nare denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat at most one apple a day (to keep the doctors away). Note\nthat you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n`, return the maximum\nnumber of apples you can eat.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def eatenApples(self, apples: List[int], days: List[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []\n\n    i = 0\n    while i < n or minHeap:\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 24, 25, 26, 27]}
{"task_num": 1706, "task_title": "Where Will the Ball Fall", "difficulty": 2, "func_name": "findBall", "description": "You have a 2-D `grid` of size `m x n` representing a box, and you have `n`\nballs. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell\nthat can redirect a ball to the right or to the left.\n\n* A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`.\n* A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck\nin the box or fall out of the bottom. A ball gets stuck if it hits a \"V\"\nshaped pattern between two boards or if a board redirects the ball into either\nwall of the box.\n\nReturn an array `answer` of size `n` where `answer[i]` is the column that the\nball falls out of at the bottom after dropping the ball from the `ith` column\nat the top, or `-1` if the ball gets stuck in the box.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findBall(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [i for i in range(n)]\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.05}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 0.99}], "target_lines": [22, 24, 30]}
{"task_num": 1707, "task_title": "Maximum XOR With an Element From Array", "difficulty": 3, "func_name": "maximizeXor", "description": "You are given an array `nums` consisting of non-negative integers. You are\nalso given a `queries` array, where `queries[i] = [xi, mi]`.\n\nThe answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and\nany element of `nums` that does not exceed `mi`. In other words, the answer is\n`max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements\nin `nums` are larger than `mi`, then the answer is `-1`.\n\nReturn an integer array `answer` where `answer.length == queries.length` and\n`answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, x: int, m: int):\n    self.queryIndex = queryIndex\n    self.x = x\n    self.m = m\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 70, "end": 71, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [26, 36, 37, 39, 41, 71]}
{"task_num": 1717, "task_title": "Maximum Score From Removing Substrings", "difficulty": 2, "func_name": "maximumGain", "description": "You are given a string `s` and two integers `x` and `y`. You can perform two\ntypes of operations any number of times.\n\n* Remove substring `\"ab\"` and gain `x` points. \n* For example, when removing `\"ab\"` from `\"cabxbae\"` it becomes `\"cxbae\"`.\n* Remove substring `\"ba\"` and gain `y` points. \n* For example, when removing `\"ba\"` from `\"cabxbae\"` it becomes `\"cabxe\"`.\n\nReturn the maximum points you can gain after applying the above operations on\n`s`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    if x > y:\n      return self._gain(s, 'ab', x, 'ba', y)\n    else:\n      return self._gain(s, 'ba', y, 'ab', x)\n\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 1, "eg_cov_prob": 0.5714285714285714}, {"type": "else", "start": 15, "end": 16, "difficulty": 1, "eg_cov_prob": 0.42857142857142855}, {"type": "if", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9795918367346939}, {"type": "else", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 16, 25, 26, 28, 32, 33, 35]}
{"task_num": 1719, "task_title": "Number Of Ways To Reconstruct A Tree", "difficulty": 3, "func_name": "checkWays", "description": "You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:\n\n* There are no duplicates.\n* `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following\nconditions:\n\n* The tree consists of nodes whose values appeared in `pairs`.\n* A pair `[xi, yi]` exists in `pairs` if and only if `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n* Note: the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has\ndifferent parents in both ways.\n\nReturn:\n\n* `0` if `ways == 0`\n* `1` if `ways == 1`\n* `2` if `ways > 1`\n\nA rooted tree is a tree that has a single root node, and all edges are\noriented to be outgoing from the root.\n\nAn ancestor of a node is any node on the path from the root to that node\n(excluding the node itself). The root has no ancestors.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def checkWays(self, pairs: List[List[int]]) -> int:\n    kMax = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * kMax\n    connected = [[False] * kMax for _ in range(kMax)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    for _, children in graph.items():\n      children.sort(key=lambda a: degrees[a], reverse=True)\n\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * kMax):\n      return 0\n    if hasMoreThanOneWay:\n      return 2\n    else:\n      return 1\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 54, "end": 55, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 56, "end": 57, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [31, 40, 44, 46, 48, 53, 55, 57]}
{"task_num": 1722, "task_title": "Minimize Hamming Distance After Swap Operations", "difficulty": 2, "func_name": "minimumHammingDistance", "description": "You are given two integer arrays, `source` and `target`, both of length `n`.\nYou are also given an array `allowedSwaps` where each `allowedSwaps[i] = [ai,\nbi]` indicates that you are allowed to swap the elements at index `ai` and\nindex `bi` (0-indexed) of array `source`. Note that you can swap elements at a\nspecific pair of indices multiple times and in any order.\n\nThe Hamming distance of two arrays of the same length, `source` and `target`,\nis the number of positions where the elements are different. Formally, it is\nthe number of indices `i` for `0 <= i <= n-1` where `source[i] != target[i]`\n(0-indexed).\n\nReturn the minimum Hamming distance of `source` and `target` after performing\nany amount of swap operations on array `source`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 53, "end": 56, "difficulty": 1, "eg_cov_prob": 0.9285714285714286}, {"type": "if", "start": 55, "end": 56, "difficulty": 1, "eg_cov_prob": 0.9285714285714286}], "target_lines": [20, 22, 24, 26, 27, 31, 52, 54, 55, 56]}
{"task_num": 1735, "task_title": "Count Ways to Make Array With Product", "difficulty": 3, "func_name": "waysToFillArray", "description": "You are given a 2D integer array, `queries`. For each `queries[i]`, where\n`queries[i] = [ni, ki]`, find the number of different ways you can place\npositive integers into an array of size `ni` such that the product of the\nintegers is `ki`. As the number of ways may be too large, the answer to the\n`ith` query is the number of ways modulo `109 + 7`.\n\nReturn an integer array `answer` where `answer.length == queries.length`, and\n`answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\n    kMod = 1_000_000_007\n    kMax = 10_000\n    minPrimeFactors = self._sieveEratosthenes(kMax + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % kMod\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, kMod - 2, kMod)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % kMod\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count\n", "blocks": [{"type": "if", "start": 42, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [43, 44]}
{"task_num": 1765, "task_title": "Map of Highest Peak", "difficulty": 2, "func_name": "highestPeak", "description": "You are given an integer matrix `isWater` of size `m x n` that represents a\nmap of land and water cells.\n\n* If `isWater[i][j] == 0`, cell `(i, j)` is a land cell.\n* If `isWater[i][j] == 1`, cell `(i, j)` is a water cell.\n\nYou must assign each cell a height in a way that follows these rules:\n\n* The height of each cell must be non-negative.\n* If the cell is a water cell, its height must be `0`.\n* Any two adjacent cells must have an absolute height difference of at most `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).\n\nFind an assignment of heights such that the maximum height in the matrix is\nmaximized.\n\nReturn an integer matrix `height` of size `m x n` where `height[i][j]` is cell\n`(i, j)`'s height. If there are multiple solutions, return any of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans\n", "blocks": [{"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 23, 31, 33]}
{"task_num": 1782, "task_title": "Count Pairs Of Nodes", "difficulty": 3, "func_name": "countPairs", "description": "You are given an undirected graph defined by an integer `n`, the number of\nnodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i]\n= [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.\nYou are also given an integer array `queries`.\n\nLet `incident(a, b)` be defined as the number of edges that are connected to\neither node `a` or `b`.\n\nThe answer to the `jth` query is the number of pairs of nodes `(a, b)` that\nsatisfy both of the following conditions:\n\n* `a < b`\n* `incident(a, b) > queries[j]`\n\nReturn an array `answers` such that `answers.length == queries.length` and\n`answers[j]` is the answer of the `jth` query.\n\nNote that there can be multiple edges between the same two nodes.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n\n    count = [0] * (n + 1)\n\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 30, "end": 32, "difficulty": 2, "eg_cov_prob": 0.04081632653061224}, {"type": "else", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.030612244897959183}], "target_lines": [31, 32, 34, 38]}
{"task_num": 1786, "task_title": "Number of Restricted Paths From First to Last Node", "difficulty": 2, "func_name": "countRestrictedPaths", "description": "There is an undirected weighted connected graph. You are given a positive\ninteger `n` which denotes that the graph has `n` nodes labeled from `1` to\n`n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes\nthat there is an edge between nodes `ui` and `vi` with weight equal to\n`weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2,\n..., zk]` such that `z0 = start` and `zk = end` and there is an edge between\n`zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let\n`distanceToLastNode(x)` denote the shortest distance of a path between node\n`n` and node `x`. A restricted path is a path that also satisfies that\n`distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn the number of restricted paths from node `1` to node `n`. Since that\nnumber may be too large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= kMod\n\n    return ways[src]\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [33, 36, 37, 39, 40]}
{"task_num": 1793, "task_title": "Maximum Score of a Good Subarray", "difficulty": 3, "func_name": "maximumScore", "description": "You are given an array of integers `nums` (0-indexed) and an integer `k`.\n\nThe score of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ...,\nnums[j]) * (j - i + 1)`. A good subarray is a subarray where `i <= k <= j`.\n\nReturn the maximum possible score of a good subarray.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        h = nums[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:\n          ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21]}
{"task_num": 1805, "task_title": "Number of Different Integers in a String", "difficulty": 1, "func_name": "numDifferentIntegers", "description": "You are given a string `word` that consists of digits and lowercase English\nletters.\n\nYou will replace every non-digit character with a space. For example,\n`\"a123bc34d8ef34\"` will become `\" 123 34 8 34\"`. Notice that you are left with\nsome integers that are separated by at least one space: `\"123\"`, `\"34\"`,\n`\"8\"`, and `\"34\"`.\n\nReturn the number of different integers after performing the replacement\noperations on `word`.\n\nTwo integers are considered different if their decimal representations without\nany leading zeros are different.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    if index == -1:\n      return ['0']\n    else:\n      return s[index:]\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.29591836734693877}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "else", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [18, 20, 21, 24, 31, 33]}
{"task_num": 1857, "task_title": "Largest Color Value in a Directed Graph", "difficulty": 3, "func_name": "largestPathValue", "description": "There is a directed graph of `n` colored nodes and `m` edges. The nodes are\nnumbered from `0` to `n - 1`.\n\nYou are given a string `colors` where `colors[i]` is a lowercase English\nletter representing the color of the `ith` node in this graph (0-indexed). You\nare also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that\nthere is a directed edge from node `aj` to node `bj`.\n\nA valid path in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk`\nsuch that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`.\nThe color value of the path is the number of nodes that are colored the most\nfrequently occurring color along that path.\n\nReturn the largest color value of any valid path in the given graph, or `-1`\nif the graph contains a cycle.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if processed == n:\n      return ans\n    else:\n      return -1\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.17346938775510204}, {"type": "else", "start": 43, "end": 44, "difficulty": 1, "eg_cov_prob": 0.826530612244898}, {"type": "if", "start": 26, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9183673469387755}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}], "target_lines": [27, 39, 42, 44]}
{"task_num": 1878, "task_title": "Get Biggest Three Rhombus Sums in a Grid", "difficulty": 2, "func_name": "getBiggestThree", "description": "You are given an `m x n` integer matrix `grid`\u200b\u200b\u200b.\n\nA rhombus sum is the sum of the elements that form the border of a regular\nrhombus shape in `grid`\u200b\u200b\u200b. The rhombus must have the shape of a square\nrotated 45 degrees with each of the corners centered in a grid cell. Below is\nan image of four valid rhombus shapes with the corresponding colored cells\nthat should be included in each rhombus sum:\n\nNote that the rhombus can have an area of 0, which is depicted by the purple\nrhombus in the bottom right corner.\n\nReturn the biggest three distinct rhombus sums in the `grid` in descending\norder. If there are less than three distinct values, return all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return reversed(sums)\n\n  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:\n    x = i\n    y = j\n    summ = 0\n\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27]}
{"task_num": 1896, "task_title": "Minimum Cost to Change the Final Value of Expression", "difficulty": 3, "func_name": "minOperationsToFlip", "description": "You are given a valid boolean expression as a string `expression` consisting\nof the characters `'1'`,`'0'`,`'&'` (bitwise AND operator),`'|'` (bitwise OR\noperator),`'('`, and `')'`.\n\n* For example, `\"()1|1\"` and `\"(1)&()\"` are not valid while `\"1\"`, `\"(((1))|(0))\"`, and `\"1|(0&(1))\"` are valid expressions.\n\nReturn the minimum cost to change the final value of the expression.\n\n* For example, if `expression = \"1|1|(0&0)&1\"`, its value is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the new expression evaluates to `0`.\n\nThe cost of changing the final value of an expression is the number of\noperations performed on the expression. The types of operations are described\nas follows:\n\n* Turn a `'1'` into a `'0'`.\n* Turn a `'0'` into a `'1'`.\n* Turn a `'&'` into a `'|'`.\n* Turn a `'|'` into a `'&'`.\n\nNote: `'&'` does not take precedence over `'|'` in the order of calculation.\nEvaluate parentheses first, then in left-to-right order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []\n\n    for e in expression:\n      if e in '(&|':\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()\n      else: \n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        if op == '&':\n          if a == '0' and b == '0':\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('0', 1)\n          else:\n            lastPair = ('1', min(costA, costB))\n        else:\n          if a == '0' and b == '0':\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            lastPair = ('1', 1)\n          else:\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]\n", "blocks": [{"type": "if", "start": 16, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 21, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "else", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 37, "difficulty": 1, "eg_cov_prob": 0.8367346938775511}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.4387755102040816}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.40816326530612246}, {"type": "if", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.5204081632653061}, {"type": "else", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.4489795918367347}, {"type": "if", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.45918367346938777}, {"type": "else", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.40816326530612246}], "target_lines": [17, 18, 20, 21, 23, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 45]}
{"task_num": 1906, "task_title": "Minimum Absolute Difference Queries", "difficulty": 2, "func_name": "minDifference", "description": "The minimum absolute difference of an array `a` is defined as the minimum\nvalue of `|a[i] - a[j]|`, where `0 <= i < j < a.length` and `a[i] != a[j]`. If\nall elements of `a` are the same, the minimum absolute difference is `-1`.\n\n* For example, the minimum absolute difference of the array `[5,2,3,7,2]` is `|2 - 3| = 1`. Note that it is not `0` because `a[i]` and `a[j]` must be different.\n\nYou are given an integer array `nums` and the array `queries` where\n`queries[i] = [li, ri]`. For each query `i`, compute the minimum absolute\ndifference of the subarray `nums[li...ri]` containing the elements of `nums`\nbetween the 0-based indices `li` and `ri` (inclusive).\n\nReturn an array `ans` where `ans[i]` is the answer to the `ith` query.\n\nA subarray is a contiguous sequence of elements in an array.\n\nThe value of `|x|` is defined as:\n\n* `x` if `x >= 0`.\n* `-x` if `x < 0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom bisect import bisect_left\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 31, 33]}
{"task_num": 1923, "task_title": "Longest Common Subpath", "difficulty": 3, "func_name": "longestCommonSubpath", "description": "There is a country of `n` cities numbered from `0` to `n - 1`. In this\ncountry, there is a road connecting every pair of cities.\n\nThere are `m` friends numbered from `0` to `m - 1` who are traveling through\nthe country. Each one of them will take a path consisting of some cities. Each\npath is represented by an integer array that contains the visited cities in\norder. The path may contain a city more than once, but the same city will not\nbe listed consecutively.\n\nGiven an integer `n` and a 2D integer array `paths` where `paths[i]` is an\ninteger array representing the path of the `ith` friend, return the length of\nthe longest common subpath that is shared by every friend's path, or `0` if\nthere is no common subpath at all.\n\nA subpath of a path is a contiguous sequence of cities within that path.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def __init__(self):\n    self.kMod = 8_417_508_174_513\n    self.kBase = 165_131\n\n  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.kBase + num) % self.kMod\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod\n      else:\n        maxPower = maxPower * self.kBase % self.kMod\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 24, "end": 25, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 25, 34, 46, 48, 50]}
{"task_num": 1926, "task_title": "Nearest Exit from Entrance in Maze", "difficulty": 2, "func_name": "nearestExit", "description": "You are given an `m x n` matrix `maze` (0-indexed) with empty cells\n(represented as `'.'`) and walls (represented as `'+'`). You are also given\nthe `entrance` of the maze, where `entrance = [entrancerow, entrancecol]`\ndenotes the row and column of the cell you are initially standing at.\n\nIn one step, you can move one cell up, down, left, or right. You cannot step\ninto a cell with a wall, and you cannot step outside the maze. Your goal is to\nfind the nearest exit from the `entrance`. An exit is defined as an empty cell\nthat is at the border of the `maze`. The `entrance` does not count as an exit.\n\nReturn the number of steps in the shortest path from the `entrance` to the\nnearest exit, or `-1` if no such path exists.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    ans = 0\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return ans\n          q.append((x, y))\n          seen.add((x, y))\n\n    return -1\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.12244897959183673}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.5204081632653061}], "target_lines": [28, 30, 32]}
{"task_num": 1928, "task_title": "Minimum Cost to Reach Destination in Time", "difficulty": 3, "func_name": "minCost", "description": "There is a country of `n` cities numbered from `0` to `n - 1` where all the\ncities are connected by bi-directional roads. The roads are represented as a\n2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road\nbetween cities `xi` and `yi` that takes `timei` minutes to travel. There may\nbe multiple roads of differing travel times connecting the same two cities,\nbut no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is\nrepresented as a 0-indexed integer array `passingFees` of length `n` where\n`passingFees[j]` is the amount of dollars you must pay when you pass through\ncity `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in\n`maxTime` minutes or less. The cost of your journey is the summation of\npassing fees for each city that you passed through at some moment of your\njourney (including the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return the minimum cost to\ncomplete your journey, or `-1` if you cannot complete it within `maxTime`\nminutes.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:\n    cost = [math.inf for _ in range(len(graph))]\n    dist = [maxTime + 1 for _ in range(len(graph))]\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 2, "eg_cov_prob": 0.09183673469387756}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.01020408163265306}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}, {"type": "if", "start": 39, "end": 42, "difficulty": 1, "eg_cov_prob": 0.6938775510204082}, {"type": "if", "start": 43, "end": 45, "difficulty": 2, "eg_cov_prob": 0.061224489795918366}], "target_lines": [33, 35, 38, 40, 41, 42, 44, 45]}
{"task_num": 1938, "task_title": "Maximum Genetic Difference Query", "difficulty": 3, "func_name": "maxGeneticDifference", "description": "There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each\nnode's number denotes its unique genetic value (i.e. the genetic value of node\n`x` is `x`). The genetic difference between two genetic values is defined as\nthe bitwise-XOR of their values. You are given the integer array `parents`,\nwhere `parents[i]` is the parent for node `i`. If node `x` is the root of the\ntree, then `parents[x] == -1`.\n\nYou are also given the array `queries` where `queries[i] = [nodei, vali]`. For\neach query `i`, find the maximum genetic difference between `vali` and `pi`,\nwhere `pi` is the genetic value of any node that is on the path between\n`nodei` and the root (including `nodei` and the root). More formally, you want\nto maximize `vali XOR pi`.\n\nReturn an array `ans` where `ans[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.kHeight = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.kHeight, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 39, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 57, "end": 58, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 38, 39, 41, 56, 58]}
{"task_num": 1971, "task_title": "Find if Path Exists in Graph", "difficulty": 1, "func_name": "validPath", "description": "There is a bi-directional graph with `n` vertices, where each vertex is\nlabeled from `0` to `n - 1` (inclusive). The edges in the graph are\nrepresented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]`\ndenotes a bi-directional edge between vertex `ui` and vertex `vi`. Every\nvertex pair is connected by at most one edge, and no vertex has an edge to\nitself.\n\nYou want to determine if there is a valid path that exists from vertex\n`source` to vertex `destination`.\n\nGiven `edges` and the integers `n`, `source`, and `destination`, return `true`\nif there is a valid path from `source` to `destination`, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.7653061224489796}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 31]}
{"task_num": 1976, "task_title": "Number of Ways to Arrive at Destination", "difficulty": 2, "func_name": "countPaths", "description": "You are in a city that consists of `n` intersections numbered from `0` to `n -\n1` with bi-directional roads between some intersections. The inputs are\ngenerated such that you can reach any intersection from any other intersection\nand that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] =\n[ui, vi, timei]` means that there is a road between intersections `ui` and\n`vi` that takes `timei` minutes to travel. You want to know in how many ways\nyou can travel from intersection `0` to intersection `n - 1` in the shortest\namount of time.\n\nReturn the number of ways you can arrive at your destination in the shortest\namount of time. Since the answer may be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countPaths(self, n: int, roads: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:\n    kMod = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= kMod\n\n    return ways[dst]\n", "blocks": [{"type": "if", "start": 32, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9897959183673469}, {"type": "if", "start": 35, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [33, 36, 37, 38, 40, 41]}
{"task_num": 1977, "task_title": "Number of Ways to Separate Numbers", "difficulty": 3, "func_name": "numberOfCombinations", "description": "You wrote down many positive integers in a string called `num`. However, you\nrealized that you forgot to add commas to seperate the different numbers. You\nremember that the list of integers was non-decreasing and that no integer had\nleading zeros.\n\nReturn the number of possible lists of integers that you could have written\ndown to get the string `num`. Since the answer may be large, return it modulo\n`109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    kMod = 1_000_000_007\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= kMod\n        s = i - k + 1\n        if num[s] == '0':\n          continue\n        if s == 0:\n          dp[i][k] += 1\n          continue\n        if s < k:\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          dp[i][k] += dp[s - 1][k]\n        else:\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % kMod\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.10204081632653061}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 33, "end": 35, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 36, "end": 38, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "if", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}, {"type": "else", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.8979591836734694}], "target_lines": [14, 24, 32, 34, 35, 37, 38, 41, 43]}
{"task_num": 1994, "task_title": "The Number of Good Subsets", "difficulty": 3, "func_name": "numberOfGoodSubsets", "description": "You are given an integer array `nums`. We call a subset of `nums` good if its\nproduct can be represented as a product of one or more distinct prime numbers.\n\n* For example, if `nums = [1, 2, 3, 4]`: \n* `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are good subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.\n* `[1, 4]` and `[4]` are not good subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn the number of different good subsets in `nums` modulo `109 + 7`.\n\nA subset of `nums` is any array that can be obtained by deleting some\n(possibly none or all) elements from `nums`. Two subsets are different if and\nonly if the chosen indices to delete are different.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfGoodSubsets(self, nums: List[int]) -> int:\n    kMod = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = 0\n      for i, prime in enumerate(primes):\n        if num % prime == 0:\n          numPrimesMask += 1 << i\n      for primesMask in range(n):\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= kMod\n\n    return (1 << count[1]) * sum(dp[1:]) % kMod\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 27, 30]}
{"task_num": 1998, "task_title": "GCD Sort of an Array", "difficulty": 3, "func_name": "gcdSort", "description": "You are given an integer array `nums`, and you can perform the following\noperation any number of times on `nums`:\n\n* Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the greatest common divisor of `nums[i]` and `nums[j]`.\n\nReturn `true` if it is possible to sort `nums` in non-decreasing order using\nthe above swap method, or `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: List[int]) -> bool:\n    maxNum = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)\n    uf = UnionFind(maxNum + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 32, 48, 56, 57]}
{"task_num": 2019, "task_title": "The Score of Students Solving Math Expression", "difficulty": 3, "func_name": "scoreOfStudents", "description": "You are given a string `s` that contains digits `0-9`, addition symbols `'+'`,\nand multiplication symbols `'*'` only, representing a valid math expression of\nsingle digit numbers (e.g., `3+5*2`). This expression was given to `n`\nelementary school students. The students were instructed to get the answer of\nthe expression by following this order of operations:\n\n1. Compute multiplication, reading from left to right; Then,\n2. Compute addition, reading from left to right.\n\nYou are given an integer array `answers` of length `n`, which are the\nsubmitted answers of the students in no particular order. You are asked to\ngrade the `answers`, by following these rules:\n\n* If an answer equals the correct answer of the expression, this student will be rewarded `5` points;\n* Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded `2` points;\n* Otherwise, this student will be rewarded `0` points.\n\nReturn the sum of the points of the students.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nimport operator\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def scoreOfStudents(self, s: str, answers: List[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans\n", "blocks": [{"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.7755102040816326}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.7346938775510204}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31, 37, 39]}
{"task_num": 2030, "task_title": "Smallest K-Length Subsequence With Occurrences of a Letter", "difficulty": 3, "func_name": "smallestSubsequence", "description": "You are given a string `s`, an integer `k`, a letter `letter`, and an integer\n`repetition`.\n\nReturn the lexicographically smallest subsequence of `s` of length `k` that\nhas the letter `letter` appear at least `repetition` times. The test cases are\ngenerated so that the `letter` appears in `s` at least `repetition` times.\n\nA subsequence is a string that can be derived from another string by deleting\nsome or no characters without changing the order of the remaining characters.\n\nA string `a` is lexicographically smaller than a string `b` if in the first\nposition where `a` and `b` differ, string `a` has a letter that appears\nearlier in the alphabet than the corresponding letter in `b`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\n    stack = []\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)\n", "blocks": [{"type": "if", "start": 21, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.9795918367346939}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 24, 25, 26, 28]}
{"task_num": 2040, "task_title": "Kth Smallest Product of Two Sorted Arrays", "difficulty": 3, "func_name": "kthSmallestProduct", "description": "Given two sorted 0-indexed integer arrays `nums1` and `nums2` as well as an\ninteger `k`, return the `kth` (1-based) smallest product of `nums1[i] *\nnums2[j]` where `0 <= i < nums1.length` and `0 <= j < nums2.length`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l\n", "blocks": [{"type": "if", "start": 20, "end": 22, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "else", "start": 23, "end": 26, "difficulty": 1, "eg_cov_prob": 0.5}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 22, 24, 25, 26, 43, 45]}
{"task_num": 2045, "task_title": "Second Minimum Time to Reach Destination", "difficulty": 3, "func_name": "secondMinimum", "description": "A city is represented as a bi-directional connected graph with `n` vertices\nwhere each vertex is labeled from `1` to `n` (inclusive). The edges in the\ngraph are represented as a 2D integer array `edges`, where each `edges[i] =\n[ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`.\nEvery vertex pair is connected by at most one edge, and no vertex has an edge\nto itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from green to red and\nvice versa every `change` minutes. All signals change at the same time. You\ncan enter a vertex at any time, but can leave a vertex only when the signal is\ngreen. You cannot wait at a vertex if the signal is green.\n\nThe second minimum value is defined as the smallest value strictly larger than\nthe minimum value.\n\n* For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return the second minimum time it\nwill take to go from vertex `1` to vertex `n`.\n\nNotes:\n\n* You can go through any vertex any number of times, including `1` and `n`.\n* You can assume that when the journey starts, all signals have just turned green.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      i, prevTime = q.popleft()\n\n      numChangeSignal = prevTime // change\n      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0\n      newTime = prevTime + waitTime + time\n      for j in graph[i]:\n        if newTime < minTime[j][0]:\n          minTime[j][0] = newTime\n          q.append((j, newTime))\n        elif minTime[j][0] < newTime < minTime[j][1]:\n          if j == n:\n            return newTime\n          minTime[j][1] = newTime\n          q.append((j, newTime))\n", "blocks": [{"type": "if", "start": 29, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 31, 33, 34, 35, 36]}
{"task_num": 2059, "task_title": "Minimum Operations to Convert Number", "difficulty": 2, "func_name": "minimumOperations", "description": "You are given a 0-indexed integer array `nums` containing distinct numbers, an\ninteger `start`, and an integer `goal`. There is an integer `x` that is\ninitially set to `start`, and you want to perform operations on `x` such that\nit is converted to `goal`. You can perform the following operation repeatedly\non the number `x`:\n\nIf `0 <= x <= 1000`, then for any index `i` in the array (`0 <= i <\nnums.length`), you can set `x` to any of the following:\n\n* `x + nums[i]`\n* `x - nums[i]`\n* `x ^ nums[i]` (bitwise-XOR)\n\nNote that you can use each `nums[i]` any number of times in any order.\nOperations that set `x` to be out of the range `0 <= x <= 1000` are valid, but\nno more operations can be done afterward.\n\nReturn the minimum number of operations needed to convert `x = start` into\n`goal`, and `-1` if it is not possible.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\n    ans = 0\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return ans\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n\n    return -1\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 26]}
{"task_num": 2076, "task_title": "Process Restricted Friend Requests", "difficulty": 3, "func_name": "friendRequests", "description": "You are given an integer `n` indicating the number of people in a network.\nEach person is labeled from `0` to `n - 1`.\n\nYou are also given a 0-indexed 2D integer array `restrictions`, where\n`restrictions[i] = [xi, yi]` means that person `xi` and person `yi` cannot\nbecome friends, either directly or indirectly through other people.\n\nInitially, no one is friends with each other. You are given a list of friend\nrequests as a 0-indexed 2D integer array `requests`, where `requests[j] = [uj,\nvj]` is a friend request between person `uj` and person `vj`.\n\nA friend request is successful if `uj` and `vj` can be friends. Each friend\nrequest is processed in the given order (i.e., `requests[j]` occurs before\n`requests[j + 1]`), and upon a successful request, `uj` and `vj` become direct\nfriends for all future friend requests.\n\nReturn a boolean array `result`, where each `result[j]` is `true` if the `jth`\nfriend request is successful or `false` if it is not.\n\nNote: If `uj` and `vj` are already direct friends, the request is still\nsuccessful.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.826530612244898}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.9489795918367347}, {"type": "else", "start": 25, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 44, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 1, "eg_cov_prob": 0.9693877551020408}, {"type": "if", "start": 48, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9081632653061225}], "target_lines": [20, 22, 24, 26, 27, 31, 45, 46, 47, 48, 49, 50, 53]}
{"task_num": 2086, "task_title": "Minimum Number of Food Buckets to Feed the Hamsters", "difficulty": 2, "func_name": "minimumBuckets", "description": "You are given a 0-indexed string `hamsters` where `hamsters[i]` is either:\n\n* `'H'` indicating that there is a hamster at index `i`, or\n* `'.'` indicating that index `i` is empty.\n\nYou will add some number of food buckets at the empty indices in order to feed\nthe hamsters. A hamster can be fed if there is at least one food bucket to its\nleft or to its right. More formally, a hamster at index `i` can be fed if you\nplace a food bucket at index `i - 1` and/or at index `i + 1`.\n\nReturn the minimum number of food buckets you should place at empty indices to\nfeed all the hamsters or `-1` if it is impossible to feed all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')\n", "blocks": [{"type": "if", "start": 16, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 1, "eg_cov_prob": 0.5306122448979592}, {"type": "if", "start": 19, "end": 20, "difficulty": 1, "eg_cov_prob": 0.6122448979591837}, {"type": "if", "start": 21, "end": 22, "difficulty": 1, "eg_cov_prob": 0.6632653061224489}, {"type": "else", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 18, 19, 20, 21, 22, 24]}
{"task_num": 2092, "task_title": "Find All People With Secret", "difficulty": 3, "func_name": "findAllPeople", "description": "You are given an integer `n` indicating there are `n` people numbered from `0`\nto `n - 1`. You are also given a 0-indexed 2D integer array `meetings` where\n`meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi`\nhave a meeting at `timei`. A person may attend multiple meetings at the same\ntime. Finally, you are given an integer `firstPerson`.\n\nPerson `0` has a secret and initially shares the secret with a person\n`firstPerson` at time `0`. This secret is then shared every time a meeting\ntakes place with a person that has the secret. More formally, for every\nmeeting, if a person `xi` has the secret at `timei`, then they will share the\nsecret with person `yi`, and vice versa.\n\nThe secrets are shared instantaneously. That is, a person may receive the\nsecret and share it with people in other meetings within the same time frame.\n\nReturn a list of all the people that have the secret after all the meetings\nhave taken place. You may return the answer in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    res=[]\n    for i in range(n):\n      if uf.connected(i, 0):\n        res.append(i)\n    return res\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.21428571428571427}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 1, "eg_cov_prob": 0.8163265306122449}, {"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.9897959183673469}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 63, "end": 64, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24, 26, 27, 37, 59, 64]}
{"task_num": 2115, "task_title": "Find All Possible Recipes from Given Supplies", "difficulty": 2, "func_name": "findAllRecipes", "description": "You have information about `n` different recipes. You are given a string array\n`recipes` and a 2D string array `ingredients`. The `ith` recipe has the name\n`recipes[i]`, and you can create it if you have all the needed ingredients\nfrom `ingredients[i]`. Ingredients to a recipe may need to be created from\nother recipes, i.e., `ingredients[i]` may contain a string that is in\n`recipes`.\n\nYou are also given a string array `supplies` containing all the ingredients\nthat you initially have, and you have an infinite supply of all of them.\n\nReturn a list of all the recipes that you can create. You may return the\nanswer in any order.\n\nNote that two recipes may contain each other in their ingredients.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [22, 23, 27, 35]}
{"task_num": 2127, "task_title": "Maximum Employees to Be Invited to a Meeting", "difficulty": 3, "func_name": "maximumInvitations", "description": "A company is organizing a meeting and has a list of `n` employees, waiting to\nbe invited. They have arranged for a large circular table, capable of seating\nany number of employees.\n\nThe employees are numbered from `0` to `n - 1`. Each employee has a favorite\nperson and they will attend the meeting only if they can sit next to their\nfavorite person at the table. The favorite person of an employee is not\nthemself.\n\nGiven a 0-indexed integer array `favorite`, where `favorite[i]` denotes the\nfavorite person of the `ith` employee, return the maximum number of employees\nthat can be invited to the meeting.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nfrom enum import Enum\n\n\nclass State(Enum):\n  kInit = 0\n  kVisiting = 1\n  kVisited = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: List[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0\n    parent = [-1] * n\n    seen = set()\n    states = [State.kInit] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.kVisiting\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.kVisiting:\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.kVisited\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)\n", "blocks": [{"type": "if", "start": 43, "end": 44, "difficulty": 2, "eg_cov_prob": 0.2641509433962264}, {"type": "if", "start": 69, "end": 70, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 58, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 59, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [39, 44, 57, 58, 60, 61, 62, 63, 64, 65, 70]}
{"task_num": 2132, "task_title": "Stamping the Grid", "difficulty": 3, "func_name": "possibleToStamp", "description": "You are given an `m x n` binary matrix `grid` where each cell is either `0`\n(empty) or `1` (occupied).\n\nYou are then given stamps of size `stampHeight x stampWidth`. We want to fit\nthe stamps such that they follow the given restrictions and requirements:\n\n1. Cover all the empty cells.\n2. Do not cover any of the occupied cells.\n3. We can put as many stamps as we want.\n4. Stamps can overlap with each other.\n5. Stamps are not allowed to be rotated.\n6. Stamps must stay completely inside the grid.\n\nReturn `true` if it is possible to fit the stamps while following the given\nrestrictions and requirements. Otherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True\n", "blocks": [{"type": "if", "start": 22, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 24, 25, 26, 35, 36, 37, 38]}
{"task_num": 2146, "task_title": "K Highest Ranked Items Within a Price Range", "difficulty": 2, "func_name": "highestRankedKItems", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n` that\nrepresents a map of the items in a shop. The integers in the grid represent\nthe following:\n\n* `0` represents a wall that you cannot pass through.\n* `1` represents an empty cell that you can freely move to and from.\n* All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes `1` step to travel between adjacent grid cells.\n\nYou are also given integer arrays `pricing` and `start` where `pricing = [low,\nhigh]` and `start = [row, col]` indicates that you start at the position\n`(row, col)` and are interested only in items with a price in the range of\n`[low, high]` (inclusive). You are further given an integer `k`.\n\nYou are interested in the positions of the `k` highest-ranked items whose\nprices are within the given price range. The rank is determined by the first\nof these criteria that is different:\n\n1. Distance, defined as the length of the shortest path from the `start` (shorter distance has a higher rank).\n2. Price (lower price has a higher rank, but it must be in the price range).\n3. The row number (smaller row number has a higher rank).\n4. The column number (smaller column number has a higher rank).\n\nReturn the `k` highest-ranked items within the price range sorted by their\nrank (highest to lowest). If there are fewer than `k` reachable items within\nthe price range, return all of them.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + dirs[t][0]\n          y = j + dirs[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans\n", "blocks": [{"type": "if", "start": 20, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 45, "end": 46, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.5283018867924528}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}], "target_lines": [21, 22, 23, 36, 38, 40, 46, 48]}
{"task_num": 2157, "task_title": "Groups of Strings", "difficulty": 3, "func_name": "groupStrings", "description": "You are given a 0-indexed array of strings `words`. Each string consists of\nlowercase English letters only. No letter occurs more than once in any string\nof `words`.\n\nTwo strings `s1` and `s2` are said to be connected if the set of letters of\n`s2` can be obtained from the set of letters of `s1` by any one of the\nfollowing operations:\n\n* Adding exactly one letter to the set of the letters of `s1`.\n* Deleting exactly one letter from the set of the letters of `s1`.\n* Replacing exactly one letter from the set of the letters of `s1` with any letter, including itself.\n\nThe array `words` can be divided into one or more non-intersecting groups. A\nstring belongs to a group if any one of the following is true:\n\n* It is connected to at least one other string of the group.\n* It is the only string present in the group.\n\nNote that the strings in `words` should be grouped in such a manner that a\nstring belonging to a group cannot be connected to a string present in any\nother group. It can be proved that such an arrangement is always unique.\n\nReturn an array `ans` of size `2` where:\n\n* `ans[0]` is the maximum number of groups `words` can be divided into, and\n* `ans[1]` is the size of the largest group.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: List[str]) -> List[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 25, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 53, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 65, "end": 66, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 67, "end": 68, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 69, "end": 70, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 23, 24, 26, 27, 32, 49, 54, 63, 66, 68, 70]}
{"task_num": 2182, "task_title": "Construct String With Repeat Limit", "difficulty": 2, "func_name": "repeatLimitedString", "description": "You are given a string `s` and an integer `repeatLimit`. Construct a new\nstring `repeatLimitedString` using the characters of `s` such that no letter\nappears more than `repeatLimit` times in a row. You do not have to use all\ncharacters from `s`.\n\nReturn the lexicographically largest `repeatLimitedString` possible.\n\nA string `a` is lexicographically larger than a string `b` if in the first\nposition where `a` and `b` differ, string `a` has a letter that appears later\nin the alphabet than the corresponding letter in `b`. If the first\n`min(a.length, b.length)` characters do not differ, then the longer string is\nthe lexicographically larger one.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 30, 36]}
{"task_num": 2203, "task_title": "Minimum Weighted Subgraph With the Required Paths", "difficulty": 3, "func_name": "minimumWeight", "description": "You are given an integer `n` denoting the number of nodes of a weighted\ndirected graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi, toi,\nweighti]` denotes that there exists a directed edge from `fromi` to `toi` with\nweight `weighti`.\n\nLastly, you are given three distinct integers `src1`, `src2`, and `dest`\ndenoting three distinct nodes of the graph.\n\nReturn the minimum weight of a subgraph of the graph such that it is possible\nto reach `dest` from both `src1` and `src2` via a set of edges of this\nsubgraph. In case such a subgraph does not exist, return `-1`.\n\nA subgraph is a graph whose vertices and edges are subsets of the original\ngraph. The weight of a subgraph is the sum of weights of its constituent\nedges.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    if minWeight == math.inf:\n      return -1\n    else:\n      return minWeight\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.7735849056603774}, {"type": "else", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.22641509433962265}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}, {"type": "if", "start": 40, "end": 42, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}], "target_lines": [25, 27, 38, 41, 42]}
{"task_num": 2242, "task_title": "Maximum Score of a Node Sequence", "difficulty": 3, "func_name": "maximumScore", "description": "There is an undirected graph with `n` nodes, numbered from `0` to `n - 1`.\n\nYou are given a 0-indexed integer array `scores` of length `n` where\n`scores[i]` denotes the score of node `i`. You are also given a 2D integer\narray `edges` where `edges[i] = [ai, bi]` denotes that there exists an\nundirected edge connecting nodes `ai` and `bi`.\n\nA node sequence is valid if it meets the following conditions:\n\n* There is an edge connecting every pair of adjacent nodes in the sequence.\n* No node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the sum of the scores of the nodes\nin the sequence.\n\nReturn the maximum score of a valid node sequence with a length of `4`. If no\nsuch sequence exists, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [28]}
{"task_num": 2245, "task_title": "Maximum Trailing Zeros in a Cornered Path", "difficulty": 2, "func_name": "maxTrailingZeros", "description": "You are given a 2D integer array `grid` of size `m x n`, where each cell\ncontains a positive integer.\n\nA cornered path is defined as a set of adjacent cells with at most one turn.\nMore specifically, the path should exclusively move either horizontally or\nvertically up to the turn (if there is one), without returning to a previously\nvisited cell. After the turn, the path will then move exclusively in the\nalternate direction: move vertically if it moved horizontally, and vice versa,\nalso without returning to a previously visited cell.\n\nThe product of a path is defined as the product of all the values in the path.\n\nReturn the maximum number of trailing zeros in the product of a cornered path\nfound in `grid`.\n\nNote:\n\n* Horizontal movement means moving in either the left or right direction.\n* Vertical movement means moving in either the up or down direction.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxTrailingZeros(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans\n", "blocks": [{"type": "if", "start": 31, "end": 33, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 39, "end": 41, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [32, 33, 40, 41]}
{"task_num": 2257, "task_title": "Count Unguarded Cells in the Grid", "difficulty": 2, "func_name": "countUnguarded", "description": "You are given two integers `m` and `n` representing a 0-indexed `m x n` grid.\nYou are also given two 2D integer arrays `guards` and `walls` where `guards[i]\n= [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the\n`ith` guard and `jth` wall respectively.\n\nA guard can see every cell in the four cardinal directions (north, east,\nsouth, or west) starting from their position unless obstructed by a wall or\nanother guard. A cell is guarded if there is at least one guard that can see\nit.\n\nReturn the number of unoccupied cells that are not guarded.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':\n          ans += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 45, "end": 46, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.8867924528301887}], "target_lines": [30, 32, 36, 38, 44, 46, 50, 52, 57]}
{"task_num": 2258, "task_title": "Escape the Spreading Fire", "difficulty": 3, "func_name": "maximumMinutes", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n` which\nrepresents a field. Each cell has one of three values:\n\n* `0` represents grass,\n* `1` represents fire,\n* `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell, `(0, 0)`, and you want to travel to the\nsafehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may\nmove to an adjacent grass cell. After your move, every fire cell will spread\nto all adjacent cells that are not walls.\n\nReturn the maximum number of minutes that you can stay in your initial\nposition before moving while still safely reaching the safehouse. If this is\nimpossible, return `-1`. If you can always reach the safehouse regardless of\nthe minutes stayed, return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have\nreached it, it will be counted as safely reaching the safehouse.\n\nA cell is adjacent to another cell if the former is directly north, east,\nsouth, or west of the latter (i.e., their sides are touching).\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumMinutes(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    kMax = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]\n    self._buildFireGrid(grid, fireGrid, dirs)\n\n    ans = -1\n    l = 0\n    r = kMax\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, dirs):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return int(1e9) if ans == kMax else ans\n\n  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          fireMinute[i][j] = 0\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:\n    q = collections.deque([(0, 0)])\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False\n", "blocks": [{"type": "if", "start": 24, "end": 26, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 38, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 68, "end": 69, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 70, "end": 71, "difficulty": 1, "eg_cov_prob": 0.6792452830188679}, {"type": "if", "start": 72, "end": 75, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 76, "end": 77, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 78, "end": 79, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 73, "end": 74, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [25, 26, 28, 39, 40, 49, 51, 53, 69, 71, 73, 74, 75, 77, 79]}
{"task_num": 2290, "task_title": "Minimum Obstacle Removal to Reach Corner", "difficulty": 3, "func_name": "minimumObstacles", "description": "You are given a 0-indexed 2D integer array `grid` of size `m x n`. Each cell\nhas one of two values:\n\n* `0` represents an empty cell,\n* `1` represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\n\nReturn the minimum number of obstacles to remove so you can move from the\nupper left corner `(0, 0)` to the lower right corner `(m - 1, n - 1)`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumObstacles(self, grid: List[List[int]]) -> int:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [23, 28, 31, 32]}
{"task_num": 2299, "task_title": "Strong Password Checker II", "difficulty": 1, "func_name": "strongPasswordCheckerII", "description": "A password is said to be strong if it satisfies all the following criteria:\n\n* It has at least `8` characters.\n* It contains at least one lowercase letter.\n* It contains at least one uppercase letter.\n* It contains at least one digit.\n* It contains at least one special character. The special characters are the characters in the following string: `\"!@#$%^&*()-+\"`.\n* It does not contain `2` of the same character in adjacent positions (i.e., `\"aab\"` violates this condition, but `\"aba\"` does not).\n\nGiven a string `password`, return `true` if it is a strong password.\nOtherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 15, "end": 16, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 17, "end": 18, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 16, 18, 20, 22]}
{"task_num": 2301, "task_title": "Match Substring After Replacement", "difficulty": 3, "func_name": "matchReplacement", "description": "You are given two strings `s` and `sub`. You are also given a 2D character\narray `mappings` where `mappings[i] = [oldi, newi]` indicates that you may\nperform the following operation any number of times:\n\n* Replace a character `oldi` of `sub` with `newi`.\n\nEach character in `sub` cannot be replaced more than once.\n\nReturn `true` if it is possible to make `sub` a substring of `s` by replacing\nzero or more characters according to `mappings`. Otherwise, return `false`.\n\nA substring is a contiguous non-empty sequence of characters within a string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True\n", "blocks": [{"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20, 26, 32]}
{"task_num": 2322, "task_title": "Minimum Score After Removals on a Tree", "difficulty": 3, "func_name": "minimumScore", "description": "There is an undirected connected tree with `n` nodes labeled from `0` to `n -\n1` and `n - 1` edges.\n\nYou are given a 0-indexed integer array `nums` of length `n` where `nums[i]`\nrepresents the value of the `ith` node. You are also given a 2D integer array\n`edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is\nan edge between nodes `ai` and `bi` in the tree.\n\nRemove two distinct edges of the tree to form three connected components. For\na pair of removed edges, the following steps are defined:\n\n1. Get the XOR of all the values of the nodes for each of the three components respectively.\n2. The difference between the largest XOR value and the smallest XOR value is the score of the pair.\n\n* For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn the minimum score of any possible pair of edge removals on the given\ntree.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Set\n\nclass Solution:\n  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(lambda x, y: x ^ y, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:\n      for v in tree[u]:\n        if v == parent:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 48, "end": 49, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 38, 42, 45, 47, 49]}
{"task_num": 2332, "task_title": "The Latest Time to Catch a Bus", "difficulty": 2, "func_name": "latestTimeCatchTheBus", "description": "You are given a 0-indexed integer array `buses` of length `n`, where\n`buses[i]` represents the departure time of the `ith` bus. You are also given\na 0-indexed integer array `passengers` of length `m`, where `passengers[j]`\nrepresents the arrival time of the `jth` passenger. All bus departure times\nare unique. All passenger arrival times are unique.\n\nYou are given an integer `capacity`, which represents the maximum number of\npassengers that can get on each bus.\n\nWhen a passenger arrives, they will wait in line for the next available bus.\nYou can get on a bus that departs at `x` minutes if you arrive at `y` minutes\nwhere `y <= x`, and the bus is not full. Passengers with the earliest arrival\ntimes get on the bus first.\n\nMore formally when a bus arrives, either:\n\n* If `capacity` or fewer passengers are waiting for a bus, they will all get on the bus, or\n* The `capacity` passengers with the earliest arrival times will get on the bus.\n\nReturn the latest time you may arrive at the bus station to catch a bus. You\ncannot arrive at the same time as another passenger.\n\nNote: The arrays `buses` and `passengers` are not necessarily sorted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0\n    j = 0\n    while i < len(buses):\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 26, 31]}
{"task_num": 2337, "task_title": "Move Pieces to Obtain a String", "difficulty": 2, "func_name": "canChange", "description": "You are given two strings `start` and `target`, both of length `n`. Each\nstring consists only of the characters `'L'`, `'R'`, and `'_'` where:\n\n* The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the left only if there is a blank space directly to its left, and a piece `'R'` can move to the right only if there is a blank space directly to its right.\n* The character `'_'` represents a blank space that can be occupied by any of the `'L'` or `'R'` pieces.\n\nReturn `true` if it is possible to obtain the string `target` by moving the\npieces of the string `start` any number of times. Otherwise, return `false`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0\n    j = 0\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}], "target_lines": [23, 25, 27, 29]}
{"task_num": 2392, "task_title": "Build a Matrix With Conditions", "difficulty": 3, "func_name": "buildMatrix", "description": "You are given a positive integer `k`. You are also given:\n\n* a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and\n* a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.\n\nThe two arrays contain integers from `1` to `k`.\n\nYou have to build a `k x k` matrix that contains each of the numbers from `1`\nto `k` exactly once. The remaining cells should have the value `0`.\n\nThe matrix should also satisfy the following conditions:\n\n* The number `abovei` should appear in a row that is strictly above the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.\n* The number `lefti` should appear in a column that is strictly left of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.\n\nReturn any matrix that satisfies the conditions. If no answer exists, return\nan empty matrix.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    if len(order) == n:\n      return order\n    else:\n      return []\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "else", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}], "target_lines": [15, 19, 50, 53, 55]}
{"task_num": 2437, "task_title": "Number of Valid Clock Times", "difficulty": 1, "func_name": "countTime", "description": "You are given a string of length `5` called `time`, representing the current\ntime on a digital clock in the format `\"hh:mm\"`. The earliest possible time is\n`\"00:00\"` and the latest possible time is `\"23:59\"`.\n\nIn the string `time`, the digits represented by the `?` symbol are unknown,\nand must be replaced with a digit from `0` to `9`.\n\nReturn an integer `answer`, the number of valid clock times that can be\ncreated by replacing every `?` with a digit from `0` to `9`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      if time[1] < '4':\n        return ans * 3\n      else:\n        return ans * 2\n    if time[1] == '?':\n      if time[0] == '2':\n        return ans * 4\n      else:\n        return ans * 10\n    return ans\n", "blocks": [{"type": "if", "start": 14, "end": 15, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}, {"type": "if", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.33962264150943394}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 21, "end": 25, "difficulty": 2, "eg_cov_prob": 0.18867924528301888}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "else", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 27, "end": 28, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "else", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}], "target_lines": [15, 17, 20, 22, 23, 25, 27, 28, 30]}
{"task_num": 2456, "task_title": "Most Popular Video Creator", "difficulty": 2, "func_name": "mostPopularCreator", "description": "You are given two string arrays `creators` and `ids`, and an integer array\n`views`, all of length `n`. The `ith` video on a platform was created by\n`creator[i]`, has an id of `ids[i]`, and has `views[i]` views.\n\nThe popularity of a creator is the sum of the number of views on all of the\ncreator's videos. Find the creator with the highest popularity and the id of\ntheir most viewed video.\n\n* If multiple creators have the highest popularity, find all of them.\n* If multiple videos have the highest view count for a creator, find the lexicographically smallest id.\n\nReturn a 2D array of strings `answer` where `answer[i] = [creatori, idi]`\nmeans that `creatori` has the highest popularity and `idi` is the id of their\nmost popular video. The answer can be returned in any order.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity\n    self.videoId = videoId\n    self.maxView = maxView\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if creator.maxView < view or creator.maxView == view and creator.videoId > id:\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans\n", "blocks": [{"type": "if", "start": 25, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [26, 27, 28, 33, 34, 38]}
{"task_num": 2462, "task_title": "Total Cost to Hire K Workers", "difficulty": 2, "func_name": "totalCost", "description": "You are given a 0-indexed integer array `costs` where `costs[i]` is the cost\nof hiring the `ith` worker.\n\nYou are also given two integers `k` and `candidates`. We want to hire exactly\n`k` workers according to the following rules:\n\n* You will run `k` sessions and hire exactly one worker in each session.\n* In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index. \n* For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.\n* In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.\n* If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n* A worker can only be chosen once.\n\nReturn the total cost to hire exactly `k` workers.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []\n    minHeapR = []\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 29, 31, 33]}
{"task_num": 2467, "task_title": "Most Profitable Path in a Tree", "difficulty": 2, "func_name": "mostProfitablePath", "description": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted\nat node `0`. You are given a 2D integer array `edges` of length `n - 1` where\n`edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and\n`bi` in the tree.\n\nAt every node `i`, there is a gate. You are also given an array of even\nintegers `amount`, where `amount[i]` represents:\n\n* the price needed to open the gate at node `i`, if `amount[i]` is negative, or,\n* the cash reward obtained on opening the gate at node `i`, otherwise.\n\nThe game goes on as follows:\n\n* Initially, Alice is at node `0` and Bob is at node `bob`.\n* At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node `0`.\n* For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: \n* If the gate is already open, no price will be required, nor will there be any cash reward.\n* If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.\n* If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are independent of each other.\n\nReturn the maximum net income Alice can have if she travels towards the\noptimal leaf node.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath\n", "blocks": [{"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}], "target_lines": [27, 35, 37, 45, 50]}
{"task_num": 2499, "task_title": "Minimum Total Cost to Make Arrays Unequal", "difficulty": 3, "func_name": "minimumTotalCost", "description": "You are given two 0-indexed integer arrays `nums1` and `nums2`, of equal\nlength `n`.\n\nIn one operation, you can swap the values of any two indices of `nums1`. The\ncost of this operation is the sum of the indices.\n\nFind the minimum total cost of performing the given operation any number of\ntimes such that `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after\nperforming all the operations.\n\nReturn the minimum total cost such that `nums1` and `nums2` satisfy the above\ncondition. In case it is not possible, return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    if maxFreq * 2 > shouldBeSwapped:\n      return -1\n    else:\n      return ans\n", "blocks": [{"type": "if", "start": 41, "end": 42, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 28, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 1, "eg_cov_prob": 0.5471698113207547}], "target_lines": [22, 23, 24, 25, 26, 27, 28, 32, 34, 37, 42, 44]}
{"task_num": 2503, "task_title": "Maximum Number of Points From Grid Queries", "difficulty": 3, "func_name": "maxPoints", "description": "You are given an `m x n` integer matrix `grid` and an array `queries` of size\n`k`.\n\nFind an array `answer` of size `k` such that for each integer `queries[i]` you\nstart in the top left cell of the matrix and repeat the following process:\n\n* If `queries[i]` is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all `4` directions: up, down, left, and right.\n* Otherwise, you do not get any points, and you end this process.\n\nAfter the process, `answer[i]` is the maximum number of points you can get.\nNote that for each query you are allowed to visit the same cell multiple\ntimes.\n\nReturn the resulting array `answer`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans\n", "blocks": [{"type": "if", "start": 34, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [35, 36, 42, 44]}
{"task_num": 2508, "task_title": "Add Edges to Make Degrees of All Nodes Even", "difficulty": 3, "func_name": "isPossible", "description": "There is an undirected graph consisting of `n` nodes numbered from `1` to `n`.\nYou are given the integer `n` and a 2D array `edges` where `edges[i] = [ai,\nbi]` indicates that there is an edge between nodes `ai` and `bi`. The graph\ncan be disconnected.\n\nYou can add at most two additional edges (possibly none) to this graph so that\nthere are no repeated edges and no self-loops.\n\nReturn `true` if it is possible to make the degree of each node in the graph\neven, otherwise return `false`.\n\nThe degree of a node is the number of edges connected to it.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])\n    return False\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 25, "end": 27, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [21, 23, 24, 26, 27]}
{"task_num": 2523, "task_title": "Closest Prime Numbers in Range", "difficulty": 2, "func_name": "closestPrimes", "description": "Given two positive integers `left` and `right`, find the two integers `num1`\nand `num2` such that:\n\n* `left <= num1 < num2 <= right `.\n* `num1` and `num2` are both prime numbers.\n* `num2 - num1` is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array `ans = [num1, num2]`. If there are multiple\npairs satisfying these conditions, return the one with the minimum `num1`\nvalue or `[-1, -1]` if such numbers do not exist.\n\nA number greater than `1` is called prime if it is only divisible by `1` and\nitself.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def closestPrimes(self, left: int, right: int) -> List[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes=[]\n    for i in range(left, right+1):\n      if isPrime[i]:\n        primes.append(i)\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> List[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 16, "end": 17, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 42, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [17, 20, 29, 30, 31, 41, 42]}
{"task_num": 2532, "task_title": "Time to Cross a Bridge", "difficulty": 3, "func_name": "findCrossingTime", "description": "There are `k` workers who want to move `n` boxes from an old warehouse to a\nnew one. You are given the two integers `n` and `k`, and a 2D integer array\n`time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti,\nputNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old\nwarehouse is on the right bank of the river, and the new warehouse is on the\nleft bank of the river. Initially, all `k` workers are waiting on the left\nside of the bridge. To move the boxes, the `ith` worker (0-indexed) can :\n\n* Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n* Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n* Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n* Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is less efficient than a worker `j` if either condition is met:\n\n* `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n* `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n* If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n* If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\n* If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\nReturn the instance of time at which the last worker reaches the left bank of\nthe river after all n boxes have been put in the new warehouse.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n    ans = 0\n    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        if leftWorkers and n > 0:\n          ans1=leftWorkers[0][0]\n        else:\n          ans1=math.inf\n        if rightWorkers:\n          ans2=rightWorkers[0][0]\n        else:\n          ans2=math.inf\n        ans=min(ans1,ans2)\n\n    return ans", "blocks": [{"type": "if", "start": 28, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 37, "end": 46, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 38, "end": 39, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "if", "start": 42, "end": 43, "difficulty": 1, "eg_cov_prob": 0.5849056603773585}, {"type": "else", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [29, 30, 31, 33, 34, 35, 36, 38, 39, 41, 42, 43, 45, 46]}
{"task_num": 2577, "task_title": "Minimum Time to Visit a Cell In a Grid", "difficulty": 3, "func_name": "minimumTime", "description": "You are given a `m x n` matrix `grid` consisting of non-negative integers\nwhere `grid[row][col]` represents the minimum time required to be able to\nvisit the cell `(row, col)`, which means you can visit the cell `(row, col)`\nonly when the time you visit it is greater than or equal to `grid[row][col]`.\n\nYou are standing in the top-left cell of the matrix in the `0th` second, and\nyou must move to any adjacent cell in the four directions: up, down, left, and\nright. Each move you make takes 1 second.\n\nReturn the minimum time required in which you can visit the bottom-right cell\nof the matrix. If you cannot visit the bottom-right cell, then return `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, grid: List[List[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in dirs:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if (grid[x][y] - time) % 2 == 0:\n          extraWait = 1\n        else:\n          extraWait = 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [14, 25, 30, 32, 34, 36]}
{"task_num": 2601, "task_title": "Prime Subtraction Operation", "difficulty": 2, "func_name": "primeSubOperation", "description": "You are given a 0-indexed integer array `nums` of length `n`.\n\nYou can perform the following operation as many times as you want:\n\n* Pick an index `i` that you haven\u2019t picked before, and pick a prime `p` strictly less than `nums[i]`, then subtract `p` from `nums[i]`.\n\nReturn true if you can make `nums` a strictly increasing array using the above\noperation and false otherwise.\n\nA strictly increasing array is an array whose each element is strictly greater\nthan its preceding element.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def primeSubOperation(self, nums: List[int]) -> bool:\n    kMax = 1000\n    primes = self._sieveEratosthenes(kMax)\n\n    prevNum = 0\n    for num in nums:\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 33, 34]}
{"task_num": 2603, "task_title": "Collect Coins in a Tree", "difficulty": 3, "func_name": "collectTheCoins", "description": "There exists an undirected and unrooted tree with `n` nodes indexed from `0`\nto `n - 1`. You are given an integer `n` and a 2D integer array edges of\nlength `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge\nbetween nodes `ai` and `bi` in the tree. You are also given an array `coins`\nof size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the\npresence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can\nperform the following operations any number of times:\n\n* Collect all the coins that are at a distance of at most `2` from the current vertex, or\n* Move to any adjacent vertex in the tree.\n\nFind the minimum number of edges you need to go through to collect all the\ncoins and go back to the initial vertex.\n\nNote that if you pass an edge several times, you need to count it into the\nanswer several times.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v\n      if len(tree[u]) == 1:\n        leavesToBeRemoved.append(u)\n\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 33, 34, 35, 36]}
{"task_num": 2653, "task_title": "Sliding Subarray Beauty", "difficulty": 2, "func_name": "getSubarrayBeauty", "description": "Given an integer array `nums` containing `n` integers, find the beauty of each\nsubarray of size `k`.\n\nThe beauty of a subarray is the `xth` smallest integer in the subarray if it\nis negative, or `0` if there are fewer than `x` negative integers.\n\nReturn an integer array containing `n - k + 1` integers, which denote the\nbeauty of the subarrays in order from the first index in the array.\n\n* A subarray is a contiguous non-empty sequence of elements within an array.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\n    ans = []\n    count = [0] * 50\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: List[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0\n", "blocks": [{"type": "if", "start": 17, "end": 18, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.5094339622641509}], "target_lines": [18, 20, 22, 31]}
{"task_num": 2662, "task_title": "Minimum Cost of a Path With Special Roads", "difficulty": 2, "func_name": "minimumCost", "description": "You are given an array `start` where `start = [startX, startY]` represents\nyour initial position `(startX, startY)` in a 2D space. You are also given the\narray `target` where `target = [targetX, targetY]` represents your target\nposition `(targetX, targetY)`.\n\nThe cost of going from a position `(x1, y1)` to any other position in the\nspace `(x2, y2)` is `|x2 - x1| + |y2 - y1|`.\n\nThere are also some special roads. You are given a 2D array `specialRoads`\nwhere `specialRoads[i] = [x1i, y1i, x2i, y2i, costi]` indicates that the `ith`\nspecial road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal\nto `costi`. You can use each special road any number of times.\n\nReturn the minimum cost required to go from `(startX, startY)` to `(targetX,\ntargetY)`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:\n    n = len(specialRoads)\n    dist = [math.inf] * n\n    minHeap = []\n\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 37, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}], "target_lines": [28, 32, 36, 37]}
{"task_num": 2663, "task_title": "Lexicographically Smallest Beautiful String", "difficulty": 3, "func_name": "smallestBeautifulString", "description": "A string is beautiful if:\n\n* It consists of the first `k` letters of the English lowercase alphabet.\n* It does not contain any substring of length `2` or more which is a palindrome.\n\nYou are given a beautiful string `s` of length `n` and a positive integer `k`.\n\nReturn the lexicographically smallest string of length `n`, which is larger\nthan `s` and is beautiful. If there is no such string, return an empty string.\n\nA string `a` is lexicographically larger than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ, `a` has a character\nstrictly larger than the corresponding character in `b`.\n\n* For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: List[str], i: int) -> bool:\n    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])\n\n  def _changeSuffix(self, chars: List[str], i: int) -> str:\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [20]}
{"task_num": 2672, "task_title": "Number of Adjacent Elements With the Same Color", "difficulty": 2, "func_name": "colorTheArray", "description": "There is a 0-indexed array `nums` of length `n`. Initially, all elements are\nuncolored (has a value of `0`).\n\nYou are given a 2D integer array `queries` where `queries[i] = [indexi,\ncolori]`.\n\nFor each query, you color the index `indexi` with the color `colori` in the\narray `nums`.\n\nReturn an array `answer` of the same length as `queries` where `answer[i]` is\nthe number of adjacent elements with the same color after the `ith` query.\n\nMore formally, `answer[i]` is the number of indices `j`, such that `0 <= j < n\n- 1` and `nums[j] == nums[j + 1]` and `nums[j] != 0` after the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans\n", "blocks": [{"type": "if", "start": 18, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.11320754716981132}, {"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.1320754716981132}, {"type": "if", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}], "target_lines": [19, 20, 21, 22, 24, 25, 26, 27]}
{"task_num": 2684, "task_title": "Maximum Number of Moves in a Grid", "difficulty": 2, "func_name": "maxMoves", "description": "You are given a 0-indexed `m x n` matrix `grid` consisting of positive\nintegers.\n\nYou can start at any cell in the first column of the matrix, and traverse the\ngrid in the following way:\n\n* From a cell `(row, col)`, you can move to any of the cells: `(row - 1, col + 1)`, `(row, col + 1)` and `(row + 1, col + 1)` such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxMoves(self, grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 22, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 24, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 24]}
{"task_num": 2685, "task_title": "Count the Number of Complete Components", "difficulty": 2, "func_name": "countCompleteComponents", "description": "You are given an integer `n`. There is an undirected graph with `n` vertices,\nnumbered from `0` to `n - 1`. You are given a 2D integer array `edges` where\n`edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting\nvertices `ai` and `bi`.\n\nReturn the number of complete connected components of the graph.\n\nA connected component is a subgraph of a graph in which there exists a path\nbetween any two vertices, and no vertex of the subgraph shares an edge with a\nvertex outside of the subgraph.\n\nA connected component is said to be complete if there exists an edge between\nevery pair of its vertices.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans\n", "blocks": [{"type": "if", "start": 22, "end": 23, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 24, "end": 27, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 28, "end": 31, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "else", "start": 32, "end": 36, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 58, "end": 60, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}], "target_lines": [23, 25, 26, 27, 29, 30, 31, 33, 34, 35, 36, 40, 59, 60]}
{"task_num": 2699, "task_title": "Modify Graph Edge Weights", "difficulty": 3, "func_name": "modifiedGraphEdges", "description": "You are given an undirected weighted connected graph containing `n` nodes\nlabeled from `0` to `n - 1`, and an integer array `edges` where `edges[i] =\n[ai, bi, wi]` indicates that there is an edge between nodes `ai` and `bi` with\nweight `wi`.\n\nSome edges have a weight of `-1` (`wi = -1`), while others have a positive\nweight (`wi > 0`).\n\nYour task is to modify all edges with a weight of `-1` by assigning them\npositive integer values in the range `[1, 2 * 109]` so that the shortest\ndistance between the nodes `source` and `destination` becomes equal to an\ninteger `target`. If there are multiple modifications that make the shortest\ndistance between `source` and `destination` equal to `target`, any of them\nwill be considered correct.\n\nReturn an array containing all edges (even unmodified ones) in any order if it\nis possible to make the shortest distance from `source` to `destination` equal\nto `target`, or an empty array if it's impossible.\n\nNote: You are not allowed to modify the weights of edges with initial positive\nweights.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\n\nclass Solution:\n  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\n    kMax = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = kMax\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = kMax\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n    minHeap = []\n    dist[src] = 0\n    heapq.heappush(minHeap, (dist[src], src))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}, {"type": "if", "start": 26, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 39, "end": 44, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 56, "end": 57, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 59, "end": 61, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}], "target_lines": [19, 25, 27, 28, 29, 30, 34, 40, 41, 42, 43, 44, 57, 60, 61]}
{"task_num": 2708, "task_title": "Maximum Strength of a Group", "difficulty": 2, "func_name": "maxStrength", "description": "You are given a 0-indexed integer array `nums` representing the score of\nstudents in an exam. The teacher would like to form one non-empty group of\nstudents with maximal strength, where the strength of a group of students of\nindices `i0`, `i1`, `i2`, ... , `ik` is defined as `nums[i0] * nums[i1] *\nnums[i2] * ... * nums[ik\u200b]`.\n\nReturn the maximum strength of a group the teacher can create.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maxStrength(self, nums: List[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.33962264150943394}, {"type": "if", "start": 35, "end": 36, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}, {"type": "if", "start": 37, "end": 38, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}, {"type": "if", "start": 21, "end": 23, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "if", "start": 24, "end": 27, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}, {"type": "else", "start": 28, "end": 29, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}], "target_lines": [22, 23, 25, 26, 27, 29, 32, 34, 36, 38, 40]}
{"task_num": 2709, "task_title": "Greatest Common Divisor Traversal", "difficulty": 3, "func_name": "canTraverseAllPairs", "description": "You are given a 0-indexed integer array `nums`, and you are allowed to\ntraverse between its indices. You can traverse between index `i` and index\n`j`, `i != j`, if and only if `gcd(nums[i], nums[j]) > 1`, where `gcd` is the\ngreatest common divisor.\n\nYour task is to determine if for every pair of indices `i` and `j` in nums,\nwhere `i < j`, there exists a sequence of traversals that can take us from `i`\nto `j`.\n\nReturn `true` if it is possible to traverse between all such pairs of indices,\nor `false` otherwise.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: List[int]) -> bool:\n    n = len(nums)\n    max_num = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors\n", "blocks": [{"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 21, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 24, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 57, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [20, 22, 23, 25, 26, 33, 48, 50, 58, 59]}
{"task_num": 2736, "task_title": "Maximum Sum Queries", "difficulty": 3, "func_name": "maximumSumQueries", "description": "You are given two 0-indexed integer arrays `nums1` and `nums2`, each of length\n`n`, and a 1-indexed 2D array `queries` where `queries[i] = [xi, yi]`.\n\nFor the `ith` query, find the maximum value of `nums1[j] + nums2[j]` among all\nindices `j` `(0 <= j < n)`, where `nums1[j] >= xi` and `nums2[j] >= yi`, or -1\nif there is no `j` satisfying the constraints.\n\nReturn an array `answer` where `answer[i]` is the answer to the `ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Pair:\n  def __init__(self, x: int, y: int):\n    self.x = x\n    self.y = y\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, minX: int, minY: int):\n    self.queryIndex = queryIndex\n    self.minX = minX\n    self.minY = minY\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      if j == len(stack):\n        ans[queryIndex] = -1\n      else:\n        ans[queryIndex] = stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 1, "eg_cov_prob": 0.9433962264150944}, {"type": "else", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 62, "end": 63, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 64, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 46, "end": 47, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [47, 51, 53, 63, 65]}
{"task_num": 2747, "task_title": "Count Zero Request Servers", "difficulty": 2, "func_name": "countServers", "description": "You are given an integer `n` denoting the total number of servers and a 2D\n0-indexed integer array `logs`, where `logs[i] = [server_id, time]` denotes\nthat the server with id `server_id` received a request at time `time`.\n\nYou are also given an integer `x` and a 0-indexed integer array `queries`.\n\nReturn a 0-indexed integer array `arr` of length `queries.length` where\n`arr[i]` represents the number of servers that did not receive any requests\nduring the time interval `[queries[i] - x, queries[i]]`.\n\nNote that the time intervals are inclusive.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, query: int):\n    self.queryIndex = queryIndex\n    self.query = query\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda log: log[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [36, 41]}
{"task_num": 2751, "task_title": "Robot Collisions", "difficulty": 3, "func_name": "survivedRobotsHealths", "description": "There are `n` 1-indexed robots, each having a position on a line, health, and\nmovement direction.\n\nYou are given 0-indexed integer arrays `positions`, `healths`, and a string\n`directions` (`directions[i]` is either 'L' for left or 'R' for right). All\nintegers in `positions` are unique.\n\nAll robots start moving on the line simultaneously at the same speed in their\ngiven directions. If two robots ever share the same position while moving,\nthey will collide.\n\nIf two robots collide, the robot with lower health is removed from the line,\nand the health of the other robot decreases by one. The surviving robot\ncontinues in the same direction it was going. If both robots have the same\nhealth, they are both removed from the line.\n\nYour task is to determine the health of the robots that survive the\ncollisions, in the same order that the robots were given, i.e. final heath of\nrobot 1 (if survived), final health of robot 2 (if survived), and so on. If\nthere are no survivors, return an empty array.\n\nReturn an array containing the health of the remaining robots (in the order\nthey were given in the input), after no further collisions can occur.\n\nNote: The positions may be unsorted.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\nfrom dataclasses import dataclass\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:\n    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)\n    stack: List[Robot] = []\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]\n", "blocks": [{"type": "if", "start": 26, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 30, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [27, 28, 31, 32, 34, 35, 37, 38, 40]}
{"task_num": 2812, "task_title": "Find the Safest Path in a Grid", "difficulty": 2, "func_name": "maximumSafenessFactor", "description": "You are given a 0-indexed 2D matrix `grid` of size `n x n`, where `(r, c)`\nrepresents:\n\n* A cell containing a thief if `grid[r][c] = 1`\n* An empty cell if `grid[r][c] = 0`\n\nYou are initially positioned at cell `(0, 0)`. In one move, you can move to\nany adjacent cell in the grid, including cells containing thieves.\n\nThe safeness factor of a path on the grid is defined as the minimum manhattan\ndistance from any cell in the path to any thief in the grid.\n\nReturn the maximum safeness factor of all paths leading to cell `(n - 1, n -\n1)`.\n\nAn adjacent cell of cell `(r, c)`, is one of the cells `(r, c + 1)`, `(r, c -\n1)`, `(r + 1, c)` and `(r - 1, c)` if it exists.\n\nThe Manhattan distance between two cells `(a, b)` and `(x, y)` is equal to `|a\n- x| + |b - y|`, where `|val|` denotes the absolute value of val.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.dirs:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 54, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 35, "end": 36, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 64, "end": 65, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 66, "end": 67, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 27, 29, 34, 36, 53, 54, 65, 67]}
{"task_num": 2818, "task_title": "Apply Operations to Maximize Score", "difficulty": 3, "func_name": "maximumScore", "description": "You are given an array `nums` of `n` positive integers and an integer `k`.\n\nInitially, you start with a score of `1`. You have to maximize your score by\napplying the following operation at most `k` times:\n\n* Choose any non-empty subarray `nums[l, ..., r]` that you haven't chosen previously.\n* Choose an element `x` of `nums[l, ..., r]` with the highest prime score. If multiple such elements exist, choose the one with the smallest index.\n* Multiply your score by `x`.\n\nHere, `nums[l, ..., r]` denotes the subarray of `nums` starting at index `l`\nand ending at the index `r`, both ends being inclusive.\n\nThe prime score of an integer `x` is equal to the number of distinct prime\nfactors of `x`. For example, the prime score of `300` is `3` since `300 = 2 *\n2 * 3 * 5 * 5`.\n\nReturn the maximum possible score after applying at most `k` operations.\n\nSince the answer may be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def maximumScore(self, nums: List[int], k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    left = [-1] * n\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n & 1:\n        return x * modPow(x, n - 1) % kMod\n      return modPow(x * x % kMod, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= kMod\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> List[int]:\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)\n", "blocks": [{"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 55, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [38, 40, 56, 57]}
{"task_num": 2836, "task_title": "Maximize Value of Function in a Ball Passing Game", "difficulty": 3, "func_name": "getMaxFunctionValue", "description": "You are given an integer array `receiver` of length `n` and an integer `k`.\n`n` players are playing a ball-passing game.\n\nYou choose the starting player, `i`. The game proceeds as follows: player `i`\npasses the ball to player `receiver[i]`, who then passes it to\n`receiver[receiver[i]]`, and so on, for `k` passes in total. The game's score\nis the sum of the indices of the players who touched the ball, including\nrepetitions, i.e. `i + receiver[i] + receiver[receiver[i]] + ... +\nreceiver(k)[i]`.\n\nReturn the maximum possible score.\n\nNotes:\n\n* `receiver` may contain duplicates.\n* `receiver[i]` may be equal to `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    jump = [[0] * m for _ in range(n)]\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        jump[i][j] = jump[midNode][j - 1]\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans\n", "blocks": [{"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [34, 35]}
{"task_num": 2844, "task_title": "Minimum Operations to Make a Special Number", "difficulty": 2, "func_name": "minimumOperations", "description": "You are given a 0-indexed string `num` representing a non-negative integer.\n\nIn one operation, you can pick any digit of `num` and delete it. Note that if\nyou delete all the digits of `num`, `num` becomes `0`.\n\nReturn the minimum number of operations required to make `num` special.\n\nAn integer `x` is considered special if it is divisible by `25`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':\n        return n - i - 2\n      if seenZero and num[i] == '5':\n        return n - i - 2\n      if seenFive and num[i] == '2':\n        return n - i - 2\n      if seenFive and num[i] == '7':\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    if seenZero:\n      return n - 1\n    else:\n      return n\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.03773584905660377}, {"type": "else", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 20, "end": 21, "difficulty": 2, "eg_cov_prob": 0.24528301886792453}, {"type": "if", "start": 22, "end": 23, "difficulty": 2, "eg_cov_prob": 0.20754716981132076}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.16981132075471697}], "target_lines": [19, 21, 23, 25, 30, 32]}
{"task_num": 2846, "task_title": "Minimum Edge Weight Equilibrium Queries in a Tree", "difficulty": 3, "func_name": "minOperationsQueries", "description": "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`. You\nare given the integer `n` and a 2D integer array `edges` of length `n - 1`,\nwhere `edges[i] = [ui, vi, wi]` indicates that there is an edge between nodes\n`ui` and `vi` with weight `wi` in the tree.\n\nYou are also given a 2D integer array `queries` of length `m`, where\n`queries[i] = [ai, bi]`. For each query, find the minimum number of operations\nrequired to make the weight of every edge on the path from `ai` to `bi` equal.\nIn one operation, you can choose any edge of the tree and change its weight to\nany value.\n\nNote that:\n\n* Queries are independent of each other, meaning that the tree returns to its initial state on each new query.\n* The path from `ai` to `bi` is a sequence of distinct nodes starting with node `ai` and ending with node `bi` such that every two adjacent nodes in the sequence share an edge in the tree.\n\nReturn an array `answer` of length `m` where `answer[i]` is the answer to the\n`ith` query.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n    kMax = 26\n    m = int(math.log2(n)) + 1\n    ans = []\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]\n    count = [[] for _ in range(n)]\n    depth = [0] * n\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int, d: int):\n      if prev != -1:\n        jump[u][0] = prev\n      depth[u] = d\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        count[v] = count[u][:]\n        count[v][w] += 1\n        dfs(v, u, d + 1)\n\n    count[0] = [0] * (kMax + 1)\n    dfs(0, -1, 0)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getLCA(u: int, v: int) -> int:\n      if depth[u] > depth[v]:\n        return getLCA(v, u)\n      for j in range(m):\n        if depth[v] - depth[u] >> j & 1:\n          v = jump[v][j]\n      if u == v:\n        return u\n      for j in range(m - 1, -1, -1):\n        if jump[u][j] != jump[v][j]:\n          u = jump[u][j]\n          v = jump[v][j]\n      return jump[v][0]\n\n    for u, v in queries:\n      lca = getLCA(u, v)\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))\n      ans.append(numEdges - maxFreq)\n\n    return ans\n", "blocks": [{"type": "if", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 44, "end": 45, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 49, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 52, "end": 54, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [27, 31, 45, 48, 50, 53, 54]}
{"task_num": 2850, "task_title": "Minimum Moves to Spread Stones Over Grid", "difficulty": 2, "func_name": "minimumMoves", "description": "You are given a 0-indexed 2D integer matrix `grid` of size `3 * 3`,\nrepresenting the number of stones in each cell. The grid contains exactly `9`\nstones, and there can be multiple stones in a single cell.\n\nIn one move, you can move a single stone from its current cell to any other\ncell if the two cells share a side.\n\nReturn the minimum number of moves required to place one stone in each cell.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumMoves(self, grid: List[List[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans\n", "blocks": [{"type": "if", "start": 13, "end": 14, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 20, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 23, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [14, 21, 22, 23, 24, 25, 26, 27, 28]}
{"task_num": 2851, "task_title": "String Transformation", "difficulty": 3, "func_name": "numberOfWays", "description": "You are given two strings `s` and `t` of equal length `n`. You can perform the\nfollowing operation on the string `s`:\n\n* Remove a suffix of `s` of length `l` where `0 < l < n` and append it at the start of `s`.  \nFor example, let `s = 'abcd'` then in one operation you can remove the suffix\n`'cd'` and append it in front of `s` making `s = 'cdab'`.\n\nYou are also given an integer `k`. Return the number of ways in which `s` can\nbe transformed into `t` in exactly `k` operations.\n\nSince the answer can be large, return it modulo `109 + 7`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    kMod = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2\n    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)\n    dp[0] = dp[1] + negOnePowK\n    res = 0\n    for index in indices:\n      if index == 0:\n        res += dp[0]\n      else: \n        res += dp[1]\n    return res % kMod\n\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "blocks": [{"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 26, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 41, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [25, 27, 38, 42, 43]}
{"task_num": 2876, "task_title": "Count Visited Nodes in a Directed Graph", "difficulty": 3, "func_name": "countVisitedNodes", "description": "There is a directed graph consisting of `n` nodes numbered from `0` to `n - 1`\nand `n` directed edges.\n\nYou are given a 0-indexed array `edges` where `edges[i]` indicates that there\nis an edge from node `i` to node `edges[i]`.\n\nConsider the following process on the graph:\n\n* You start from a node `x` and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.\n\nReturn an array `answer` where `answer[i]` is the number of different nodes\nthat you will visit if you perform the process starting from node `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countVisitedNodes(self, edges: List[int]) -> List[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [28, 34]}
{"task_num": 2901, "task_title": "Longest Unequal Adjacent Groups Subsequence II", "difficulty": 2, "func_name": "getWordsInLongestSubsequence", "description": "You are given a string array `words`, and an array `groups`, both arrays\nhaving length `n`.\n\nThe hamming distance between two strings of equal length is the number of\npositions at which the corresponding characters are different.\n\nYou need to select the longest subsequence from an array of indices `[0, 1,\n..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik-1]`\nhaving length `k`, the following holds:\n\n* For adjacent indices in the subsequence, their corresponding groups are unequal, i.e., `groups[ij] != groups[ij+1]`, for each `j` where `0 < j + 1 < k`.\n* `words[ij]` and `words[ij+1]` are equal in length, and the hamming distance between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.\n\nReturn a string array containing the words corresponding to the indices (in\norder) in the selected subsequence. If there are multiple answers, return any\nof them.\n\nNote: strings in `words` may be unequal in length.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n    ans = []\n    n=len(words)\n    dp = [1] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 23, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 25, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 26, "end": 28, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [21, 23, 25, 27, 28]}
{"task_num": 2904, "task_title": "Shortest and Lexicographically Smallest Beautiful String", "difficulty": 2, "func_name": "shortestBeautifulSubstring", "description": "You are given a binary string `s` and a positive integer `k`.\n\nA substring of `s` is beautiful if the number of `1`'s in it is exactly `k`.\n\nLet `len` be the length of the shortest beautiful substring.\n\nReturn the lexicographically smallest beautiful substring of string `s` with\nlength equal to `len`. If `s` doesn't contain a beautiful substring, return an\nempty string.\n\nA string `a` is lexicographically larger than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ, `a` has a character\nstrictly larger than the corresponding character in `b`.\n\n* For example, `\"abcd\"` is lexicographically larger than `\"abcc\"` because the first position they differ is at the fourth character, and `d` is greater than `c`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    if bestLeft == -1:\n      return \"\"\n    else:\n      return s[bestLeft:bestLeft + minLength]\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.5094339622641509}, {"type": "else", "start": 33, "end": 34, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 19, "end": 20, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 22, "end": 24, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 27, "end": 28, "difficulty": 1, "eg_cov_prob": 0.49056603773584906}, {"type": "if", "start": 25, "end": 26, "difficulty": 1, "eg_cov_prob": 0.4339622641509434}], "target_lines": [20, 23, 24, 26, 28, 32, 34]}
{"task_num": 2911, "task_title": "Minimum Changes to Make K Semi-palindromes", "difficulty": 3, "func_name": "minimumChanges", "description": "Given a string `s` and an integer `k`, partition `s` into `k` substrings such\nthat the letter changes needed to make each substring a semi-palindrome are\nminimized.\n\nReturn the minimum number of letter changes required.\n\nA semi-palindrome is a special type of string that can be divided into\npalindromes based on a repeating pattern. To check if a string is a semi-\npalindrome:\u200b\n\n1. Choose a positive divisor `d` of the string's length. `d` can range from `1` up to, but not including, the string's length. For a string of length `1`, it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed.\n2. For a given divisor `d`, divide the string into groups where each group contains characters from the string that follow a repeating pattern of length `d`. Specifically, the first group consists of characters at positions `1`, `1 + d`, `1 + 2d`, and so on; the second group includes characters at positions `2`, `2 + d`, `2 + 2d`, etc.\n3. The string is considered a semi-palindrome if each of these groups forms a palindrome.\n\nConsider the string `\"abcabc\"`:\n\n* The length of `\"abcabc\"` is `6`. Valid divisors are `1`, `2`, and `3`.\n* For `d = 1`: The entire string `\"abcabc\"` forms one group. Not a palindrome.\n* For `d = 2`: \n* Group 1 (positions `1, 3, 5`): `\"acb\"`\n* Group 2 (positions `2, 4, 6`): `\"bac\"`\n* Neither group forms a palindrome.\n* For `d = 3`: \n* Group 1 (positions `1, 4`): `\"aa\"`\n* Group 2 (positions `2, 5`): `\"bb\"`\n* Group 3 (positions `3, 6`): `\"cc\"`\n* All groups form palindromes. Therefore, `\"abcabc\"` is a semi-palindrome.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    factors = self._getFactors(n)\n    cost = self._getCost(s, n, factors)\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> List[List[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i in range(n):\n      for j in range(i + 1, n):\n        length = j - i + 1\n        minCost = length\n        for d in factors[length]:\n          minCost = min(minCost, self._getCostD(s, i, j, d))\n        cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost\n", "blocks": [{"type": "if", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [52]}
{"task_num": 2932, "task_title": "Maximum Strong Pair XOR I", "difficulty": 1, "func_name": "maximumStrongPairXor", "description": "You are given a 0-indexed integer array `nums`. A pair of integers `x` and `y`\nis called a strong pair if it satisfies the condition:\n\n* `|x - y| <= min(x, y)`\n\nYou need to select two integers from `nums` such that they form a strong pair\nand their bitwise `XOR` is the maximum among all strong pairs in the array.\n\nReturn the maximum `XOR` value out of all possible strong pairs in the array\n`nums`.\n\nNote that you can pick the same integer twice to form a pair.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator, Optional\n\nclass TrieNode:\n  def __init__(self):\n    self.children: List[Optional[TrieNode]] = [None] * 2\n    self.min = math.inf\n    self.max = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.min = min(node.min, num)\n      node.max = max(node.max, num)\n\n  def getMaxXor(self, x: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maximumStrongPairXor(self, nums: List[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 43, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 44, "end": 45, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [28, 40, 41, 43, 45]}
{"task_num": 2940, "task_title": "Find Building Where Alice and Bob Can Meet", "difficulty": 3, "func_name": "leftmostBuildingQueries", "description": "You are given a 0-indexed array `heights` of positive integers, where\n`heights[i]` represents the height of the `ith` building.\n\nIf a person is in building `i`, they can move to any other building `j` if and\nonly if `i < j` and `heights[i] < heights[j]`.\n\nYou are also given another array `queries` where `queries[i] = [ai, bi]`. On\nthe `ith` query, Alice is in building `ai` while Bob is in building `bi`.\n\nReturn an array `ans` where `ans[i]` is the index of the leftmost building\nwhere Alice and Bob can meet on the `ith` query. If Alice and Bob cannot move\nto a common building on query `i`, set `ans[i]` to `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass IndexedQuery:\n  def __init__(self, queryIndex: int, a: int, b: int):\n    self.queryIndex = queryIndex\n    self.a = a\n    self.b = b\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n    ans = [-1] * len(queries)\n    stack = []\n\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):\n      if a == b or heights[a] < heights[b]:\n        ans[queryIndex] = b\n      else:\n        while heightsIndex > b:\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: List[int], target: int, heights: List[int]):\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 32, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 49, "end": 50, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31, 33, 34, 35, 36, 37, 38, 39, 40, 50, 52]}
{"task_num": 2948, "task_title": "Make Lexicographically Smallest Array by Swapping Elements", "difficulty": 2, "func_name": "lexicographicallySmallestArray", "description": "You are given a 0-indexed array of positive integers `nums` and a positive\ninteger `limit`.\n\nIn one operation, you can choose any two indices `i` and `j` and swap\n`nums[i]` and `nums[j]` if `|nums[i] - nums[j]| <= limit`.\n\nReturn the lexicographically smallest array that can be obtained by performing\nthe operation any number of times.\n\nAn array `a` is lexicographically smaller than an array `b` if in the first\nposition where `a` and `b` differ, array `a` has an element that is less than\nthe corresponding element in `b`. For example, the array `[2,10,3]` is\nlexicographically smaller than the array `[10,2,3]` because they differ at\nindex `0` and `2 < 10`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    numAndIndexesGroups: List[List[Tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [19, 21]}
{"task_num": 2953, "task_title": "Count Complete Substrings", "difficulty": 3, "func_name": "countCompleteSubstrings", "description": "You are given a string `word` and an integer `k`.\n\nA substring `s` of `word` is complete if:\n\n* Each character in `s` occurs exactly `k` times.\n* The difference between two adjacent characters is at most `2`. That is, for any two adjacent characters `c1` and `c2` in `s`, the absolute difference in their positions in the alphabet is at most `2`.\n\nReturn the number of complete substrings of `word`.\n\nA substring is a non-empty contiguous sequence of characters in a string.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    res = 0\n    countLetters = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res\n", "blocks": [{"type": "if", "start": 24, "end": 27, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 28, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [25, 26, 27, 29, 30, 32]}
{"task_num": 2959, "task_title": "Number of Possible Sets of Closing Branches", "difficulty": 3, "func_name": "numberOfSets", "description": "There is a company with `n` branches across the country, some of which are\nconnected by roads. Initially, all branches are reachable from each other by\ntraveling some roads.\n\nThe company has realized that they are spending an excessive amount of time\ntraveling between their branches. As a result, they have decided to close down\nsome of these branches (possibly none). However, they want to ensure that the\nremaining branches have a distance of at most `maxDistance` from each other.\n\nThe distance between two branches is the minimum total traveled length needed\nto reach one branch from another.\n\nYou are given integers `n`, `maxDistance`, and a 0-indexed 2D array `roads`,\nwhere `roads[i] = [ui, vi, wi]` represents the undirected road between\nbranches `ui` and `vi` with length `wi`.\n\nReturn the number of possible sets of closing branches, so that any branch has\na distance of at most `maxDistance` from any other.\n\nNote that, after closing a branch, the company will no longer have access to\nany roads connected to it.\n\nNote that, multiple roads are allowed.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))\n\n  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance\n", "blocks": [{"type": "if", "start": 20, "end": 21, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 24, "end": 26, "difficulty": 1, "eg_cov_prob": 0.8301886792452831}, {"type": "if", "start": 29, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.8867924528301887}, {"type": "if", "start": 33, "end": 34, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [21, 25, 26, 30, 31, 32, 33, 34, 38, 39, 40]}
{"task_num": 2973, "task_title": "Find Number of Coins to Place in Tree Nodes", "difficulty": 3, "func_name": "placedCoins", "description": "You are given an undirected tree with `n` nodes labeled from `0` to `n - 1`,\nand rooted at node `0`. You are given a 2D integer array `edges` of length `n\n- 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between\nnodes `ai` and `bi` in the tree.\n\nYou are also given a 0-indexed integer array `cost` of length `n`, where\n`cost[i]` is the cost assigned to the `ith` node.\n\nYou need to place some coins on every node of the tree. The number of coins to\nbe placed at node `i` can be calculated as:\n\n* If size of the subtree of node `i` is less than `3`, place `1` coin.\n* Otherwise, place an amount of coins equal to the maximum product of cost values assigned to `3` distinct nodes in the subtree of node `i`. If this product is negative, place `0` coins.\n\nReturn an array `coin` of size `n` such that `coin[i]` is the number of coins\nplaced at node `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans\n", "blocks": [{"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 33, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [28, 30, 33, 35, 53]}
{"task_num": 2976, "task_title": "Minimum Cost to Convert String I", "difficulty": 2, "func_name": "minimumCost", "description": "You are given two 0-indexed strings `source` and `target`, both of length `n`\nand consisting of lowercase English letters. You are also given two 0-indexed\ncharacter arrays `original` and `changed`, and an integer array `cost`, where\n`cost[i]` represents the cost of changing the character `original[i]` to the\ncharacter `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a character\n`x` from the string and change it to the character `y` at a cost of `z` if\nthere exists any index `j` such that `cost[j] == z`, `original[j] == x`, and\n`changed[j] == y`.\n\nReturn the minimum cost to convert the string `source` to the string `target`\nusing any number of operations. If it is impossible to convert `source` to\n`target`, return `-1`.\n\nNote that there may exist indices `i`, `j` such that `original[j] ==\noriginal[i]` and `changed[j] == changed[i]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    ans = 0\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.9433962264150944}, {"type": "if", "start": 33, "end": 34, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 23, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 25, 26, 30, 34]}
{"task_num": 2977, "task_title": "Minimum Cost to Convert String II", "difficulty": 3, "func_name": "minimumCost", "description": "You are given two 0-indexed strings `source` and `target`, both of length `n`\nand consisting of lowercase English characters. You are also given two\n0-indexed string arrays `original` and `changed`, and an integer array `cost`,\nwhere `cost[i]` represents the cost of converting the string `original[i]` to\nthe string `changed[i]`.\n\nYou start with the string `source`. In one operation, you can pick a substring\n`x` from the string, and change it to `y` at a cost of `z` if there exists any\nindex `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`.\nYou are allowed to do any number of operations, but any pair of operations\nmust satisfy either of these two conditions:\n\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` or `d < a`. In other words, the indices picked in both operations are disjoint.\n* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` and `b == d`. In other words, the indices picked in both operations are identical.\n\nReturn the minimum cost to convert the string `source` to the string `target`\nusing any number of operations. If it is impossible to convert `source` to\n`target`, return `-1`.\n\nNote that there may exist indices `i`, `j` such that `original[j] ==\noriginal[i]` and `changed[j] == changed[i]`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    if dp[len(source)] == math.inf:\n      return -1\n    else:\n      return dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 52, "end": 53, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 37, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 58, "end": 59, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 26, "end": 29, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 43, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 47, "end": 48, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 28, "end": 29, "difficulty": 2, "eg_cov_prob": 0.0}], "target_lines": [27, 28, 29, 35, 37, 40, 44, 48, 51, 53, 59]}
{"task_num": 2983, "task_title": "Palindrome Rearrangement Queries", "difficulty": 3, "func_name": "canMakePalindromeQueries", "description": "You are given a 0-indexed string `s` having an even length `n`.\n\nYou are also given a 0-indexed 2D integer array, `queries`, where `queries[i]\n= [ai, bi, ci, di]`.\n\nFor each query `i`, you are allowed to perform the following operations:\n\n* Rearrange the characters within the substring `s[ai:bi]`, where `0 <= ai <= bi < n / 2`.\n* Rearrange the characters within the substring `s[ci:di]`, where `n / 2 <= ci <= di < n`.\n\nFor each query, your task is to determine whether it is possible to make `s` a\npalindrome by performing the operations.\n\nEach query is answered independently of the others.\n\nReturn a 0-indexed array `answer`, where `answer[i] == true` if it is possible\nto make `s` a palindrome by performing operations specified by the `ith`\nquery, and `false` otherwise.\n\n* A substring is a contiguous sequence of characters within a string.\n* `s[x:y]` represents the substring consisting of characters from the index `x` to index `y` in `s`, both inclusive.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n    n = len(s)\n    mirroredDiffs = self._getMirroredDiffs(s)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: List[int], b: List[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      b += 1\n      d += 1\n      ra = n - a\n      rb = n - b\n      rc = n - c\n      rd = n - d\n\n      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):\n        ans.append(False)\n      else:\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> List[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> List[List[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 31, "end": 48, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 55, "end": 56, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 36, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 37, "end": 39, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 40, "end": 42, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 43, "end": 45, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}], "target_lines": [30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 56]}
{"task_num": 3001, "task_title": "Minimum Moves to Capture The Queen", "difficulty": 2, "func_name": "minMovesToCaptureTheQueen", "description": "There is a 1-indexed `8 x 8` chessboard containing `3` pieces.\n\nYou are given `6` integers `a`, `b`, `c`, `d`, `e`, and `f` where:\n\n* `(a, b)` denotes the position of the white rook.\n* `(c, d)` denotes the position of the white bishop.\n* `(e, f)` denotes the position of the black queen.\n\nGiven that you can only move the white pieces, return the minimum number of\nmoves required to capture the black queen.\n\nNote that:\n\n* Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.\n* Bishops can move any number of squares diagonally, but cannot jump over other pieces.\n* A rook or a bishop can capture the queen if it is located in a square that they can move to.\n* The queen does not move.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n    if a == e:\n      if c == a and (b < d < f or b > d > f):\n        return 2\n      else:\n        return 1\n    if b == f:\n      if d == f and (a < c < e or a > c > e):\n        return 2\n      else:\n        return 1\n    if c + d == e + f:\n      if a + b == c + d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    if c - d == e - f:\n      if a - b == c - d and (c < a < e or c > a > e):\n        return 2\n      else:\n        return 1\n    return 2\n", "blocks": [{"type": "if", "start": 13, "end": 17, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 18, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 23, "end": 27, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 28, "end": 32, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 14, "end": 15, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 16, "end": 17, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 19, "end": 20, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.09433962264150944}, {"type": "if", "start": 24, "end": 25, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 26, "end": 27, "difficulty": 2, "eg_cov_prob": 0.05660377358490566}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "else", "start": 31, "end": 32, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}], "target_lines": [14, 15, 17, 19, 20, 22, 24, 25, 27, 29, 30, 32]}
{"task_num": 3006, "task_title": "Find Beautiful Indices in the Given Array I", "difficulty": 2, "func_name": "beautifulIndices", "description": "You are given a 0-indexed string `s`, a string `a`, a string `b`, and an\ninteger `k`.\n\nAn index `i` is beautiful if:\n\n* `0 <= i <= s.length - a.length`\n* `s[i..(i + a.length - 1)] == a`\n* There exists an index `j` such that: \n* `0 <= j <= s.length - b.length`\n* `s[j..(j + b.length - 1)] == b`\n* `|j - i| <= k`\n\nReturn the array that contains beautiful indices in sorted order from smallest\nto largest.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0\n\n    for i in indicesA:\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> List[int]:\n    def getLPS(pattern: str) -> List[int]:\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0\n    j = 0\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res\n", "blocks": [{"type": "if", "start": 21, "end": 22, "difficulty": 2, "eg_cov_prob": 0.24528301886792453}, {"type": "if", "start": 43, "end": 48, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 2, "eg_cov_prob": 0.37735849056603776}, {"type": "if", "start": 46, "end": 48, "difficulty": 2, "eg_cov_prob": 0.2830188679245283}, {"type": "if", "start": 49, "end": 50, "difficulty": 1, "eg_cov_prob": 0.9056603773584906}, {"type": "else", "start": 51, "end": 52, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [22, 34, 35, 44, 45, 46, 47, 48, 50, 52]}
{"task_num": 3029, "task_title": "Minimum Time to Revert Word to Initial State I", "difficulty": 2, "func_name": "minimumTimeToInitialState", "description": "You are given a 0-indexed string `word` and an integer `k`.\n\nAt every second, you must perform the following operations:\n\n* Remove the first `k` characters of `word`.\n* Add any `k` characters to the end of `word`.\n\nNote that you do not necessarily need to add the same characters that you\nremoved. However, you must perform both operations at every second.\n\nReturn the minimum time greater than zero required for `word` to revert to its\ninitial state.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> List[int]:\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z\n", "blocks": [{"type": "if", "start": 18, "end": 19, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.018867924528301886}, {"type": "if", "start": 33, "end": 35, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}], "target_lines": [19, 30, 34, 35]}
{"task_num": 3030, "task_title": "Find the Grid of Region Average", "difficulty": 2, "func_name": "resultGrid", "description": "You are given a 0-indexed `m x n` grid `image` which represents a grayscale\nimage, where `image[i][j]` represents a pixel with intensity in the\nrange`[0..255]`. You are also given a non-negative integer `threshold`.\n\nTwo pixels `image[a][b]` and `image[c][d]` are said to be adjacent if `|a - c|\n+ |b - d| == 1`.\n\nA region is a `3 x 3` subgrid where the absolute difference in intensity\nbetween any two adjacent pixels is less than or equal to `threshold`.\n\nAll pixels in a region belong to that region, note that a pixel can belong to\nmultiple regions.\n\nYou need to calculate a 0-indexed `m x n` grid `result`, where `result[i][j]`\nis the average intensity of the region to which `image[i][j]` belongs, rounded\ndown to the nearest integer. If `image[i][j]` belongs to multiple regions,\n`result[i][j]` is the average of the rounded down average intensities of these\nregions, rounded down to the nearest integer. If `image[i][j]` does not belong\nto any region, `result[i][j]` is equal to `image[i][j]`.\n\nReturn the grid `result`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True\n", "blocks": [{"type": "if", "start": 20, "end": 25, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 29, "end": 30, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}, {"type": "if", "start": 37, "end": 38, "difficulty": 1, "eg_cov_prob": 0.9622641509433962}, {"type": "if", "start": 39, "end": 40, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}], "target_lines": [21, 22, 23, 24, 25, 30, 38, 40]}
{"task_num": 3043, "task_title": "Find the Length of the Longest Common Prefix", "difficulty": 2, "func_name": "longestCommonPrefix", "description": "You are given two arrays with positive integers `arr1` and `arr2`.\n\nA prefix of a positive integer is an integer formed by one or more of its\ndigits, starting from its leftmost digit. For example, `123` is a prefix of\nthe integer `12345`, while `234` is not.\n\nA common prefix of two integers `a` and `b` is an integer `c`, such that `c`\nis a prefix of both `a` and `b`. For example, `5655359` and `56554` have a\ncommon prefix `565` while `1223` and `43456` do not have a common prefix.\n\nYou need to find the length of the longest common prefix between all pairs of\nintegers `(x, y)` such that `x` belongs to `arr1` and `y` belongs to `arr2`.\n\nReturn the length of the longest common prefix among all pairs. If no common\nprefix exists among them, return `0`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass TrieNode:\n  def __init__(self):\n    self.children: Dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)\n", "blocks": [{"type": "if", "start": 30, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [31]}
{"task_num": 3044, "task_title": "Most Frequent Prime", "difficulty": 2, "func_name": "mostFrequentPrime", "description": "You are given a `m x n` 0-indexed 2D matrix `mat`. From every cell, you can\ncreate numbers in the following way:\n\n* There could be at most `8` paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.\n* Select a path from them and append digits in this path to the number being formed by traveling in this direction.\n* Note that numbers are generated at every step, for example, if the digits along the path are `1, 9, 1`, then there will be three numbers generated along the way: `1, 19, 191`.\n\nReturn the most frequent prime number greater than `10` out of all the numbers\ncreated by traversing the matrix or `-1` if no such prime number exists. If\nthere are multiple prime numbers with the highest frequency, then return the\nlargest among them.\n\nNote: It is invalid to change the direction during the move.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def mostFrequentPrime(self, mat: List[List[int]]) -> int:\n    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in dirs:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]\n", "blocks": [{"type": "if", "start": 35, "end": 36, "difficulty": 2, "eg_cov_prob": 0.07547169811320754}, {"type": "if", "start": 30, "end": 31, "difficulty": 1, "eg_cov_prob": 0.9245283018867925}], "target_lines": [31, 36]}
{"task_num": 3072, "task_title": "Distribute Elements Into Two Arrays II", "difficulty": 3, "func_name": "resultArray", "description": "You are given a 1-indexed array of integers `nums` of length `n`.\n\nWe define a function `greaterCount` such that `greaterCount(arr, val)` returns\nthe number of elements in `arr` that are strictly greater than `val`.\n\nYou need to distribute all the elements of `nums` between two arrays `arr1`\nand `arr2` using `n` operations. In the first operation, append `nums[1]` to\n`arr1`. In the second operation, append `nums[2]` to `arr2`. Afterwards, in\nthe `ith` operation:\n\n* If `greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i])`, append `nums[i]` to `arr1`.\n* If `greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i])`, append `nums[i]` to `arr2`.\n* If `greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])`, append `nums[i]` to the array with a lesser number of elements.\n* If there is still a tie, append `nums[i]` to `arr1`.\n\nThe array `result` is formed by concatenating the arrays `arr1` and `arr2`.\nFor example, if `arr1 == [1,2,3]` and `arr2 == [4,5,6]`, then `result =\n[1,2,3,4,5,6]`.\n\nReturn the integer array `result`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def update(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: List[int]) -> List[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: List[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.update(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: List[int]) -> Dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks\n", "blocks": [{"type": "if", "start": 50, "end": 51, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 52, "end": 53, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 54, "end": 55, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 56, "end": 57, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [51, 53, 55, 57]}
{"task_num": 3095, "task_title": "Shortest Subarray With OR at Least K I", "difficulty": 1, "func_name": "minimumSubarrayLength", "description": "You are given an array `nums` of non-negative integers and an integer `k`.\n\nAn array is called special if the bitwise `OR` of all of its elements is at\nleast `k`.\n\nReturn the length of the shortest special non-empty subarray of `nums`, or\nreturn `-1` if no special subarray exists.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors\n", "blocks": [{"type": "if", "start": 29, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 37, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 31, "end": 32, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 40, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 31, 32, 38, 39, 40]}
{"task_num": 3102, "task_title": "Minimize Manhattan Distances", "difficulty": 3, "func_name": "minimumDistance", "description": "You are given a array `points` representing integer coordinates of some points\non a 2D plane, where `points[i] = [xi, yi]`.\n\nThe distance between two points is defined as their Manhattan distance.\n\nReturn the minimum possible value for maximum distance between any two points\nby removing exactly one point.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumDistance(self, points: List[List[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    if maxSum - minSum >= maxDiff - minDiff:\n      return [minSumIndex, maxSumIndex]\n    else:\n      return [minDiffIndex, maxDiffIndex]\n\n  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n", "blocks": [{"type": "if", "start": 46, "end": 47, "difficulty": 1, "eg_cov_prob": 0.7735849056603774}, {"type": "else", "start": 48, "end": 49, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "if", "start": 29, "end": 30, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 33, "end": 35, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 36, "end": 38, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 39, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 42, "end": 44, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [30, 34, 35, 37, 38, 40, 41, 43, 44, 47, 49]}
{"task_num": 3108, "task_title": "Minimum Cost Walk in Weighted Graph", "difficulty": 3, "func_name": "minimumCost", "description": "There is an undirected weighted graph with `n` vertices labeled from `0` to `n\n- 1`.\n\nYou are given the integer `n` and an array `edges`, where `edges[i] = [ui, vi,\nwi]` indicates that there is an edge between vertices `ui` and `vi` with a\nweight of `wi`.\n\nA walk on a graph is a sequence of vertices and edges. The walk starts and\nends with a vertex, and each edge connects the vertex that comes before it and\nthe vertex that comes after it. It's important to note that a walk may visit\nthe same edge or vertex more than once.\n\nThe cost of a walk starting at node `u` and ending at node `v` is defined as\nthe bitwise `AND` of the weights of the edges traversed during the walk. In\nother words, if the sequence of edge weights encountered during the walk is\n`w0, w1, w2, ..., wk`, then the cost is calculated as `w0 & w1 & w2 & ... &\nwk`, where `&` denotes the bitwise `AND` operator.\n\nYou are also given a 2D array `query`, where `query[i] = [si, ti]`. For each\nquery, you need to find the minimum cost of the walk starting at vertex `si`\nand ending at vertex `ti`. If there exists no such walk, the answer is `-1`.\n\nReturn the array `answer`, where `answer[i]` denotes the minimum cost of a\nwalk for query `i`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return self.weight[i]\n    else:\n      return -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]\n", "blocks": [{"type": "if", "start": 23, "end": 24, "difficulty": 1, "eg_cov_prob": 0.7358490566037735}, {"type": "if", "start": 25, "end": 26, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 34, "end": 35, "difficulty": 2, "eg_cov_prob": 0.0}, {"type": "if", "start": 38, "end": 39, "difficulty": 1, "eg_cov_prob": 0.8490566037735849}, {"type": "else", "start": 40, "end": 41, "difficulty": 1, "eg_cov_prob": 0.9811320754716981}, {"type": "if", "start": 44, "end": 45, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 27, "end": 28, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 29, "end": 31, "difficulty": 0, "eg_cov_prob": 1.0}], "target_lines": [24, 26, 28, 30, 31, 35, 39, 41, 45]}
{"task_num": 3112, "task_title": "Minimum Time to Visit Disappearing Nodes", "difficulty": 2, "func_name": "minimumTime", "description": "There is an undirected graph of `n` nodes. You are given a 2D array `edges`,\nwhere `edges[i] = [ui, vi, lengthi]` describes an edge between node `ui` and\nnode `vi` with a traversal time of `lengthi` units.\n\nAdditionally, you are given an array `disappear`, where `disappear[i]` denotes\nthe time when the node `i` disappears from the graph and you won't be able to\nvisit it.\n\nNotice that the graph might be disconnected and might contain multiple edges.\n\nReturn the array `answer`, with `answer[i]` denoting the minimum units of time\nrequired to reach node `i` from node 0. If node `i` is unreachable from node 0\nthen `answer[i]` is `-1`.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    res=[]\n    for d in dist:\n      if d != math.inf:\n        res.append(d)\n      else:\n        res.append(-1)\n    return res\n", "blocks": [{"type": "if", "start": 29, "end": 30, "difficulty": 2, "eg_cov_prob": 0.1509433962264151}, {"type": "if", "start": 38, "end": 39, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "else", "start": 40, "end": 41, "difficulty": 0, "eg_cov_prob": 1.0}, {"type": "if", "start": 32, "end": 34, "difficulty": 1, "eg_cov_prob": 0.660377358490566}], "target_lines": [30, 33, 34, 39, 41]}
{"task_num": 3123, "task_title": "Find Edges in Shortest Paths", "difficulty": 3, "func_name": "findAnswer", "description": "You are given an undirected weighted graph of `n` nodes numbered from 0 to `n\n- 1`. The graph consists of `m` edges represented by a 2D array `edges`, where\n`edges[i] = [ai, bi, wi]` indicates that there is an edge between nodes `ai`\nand `bi` with weight `wi`.\n\nConsider all the shortest paths from node 0 to node `n - 1` in the graph. You\nneed to find a boolean array `answer` where `answer[i]` is `true` if the edge\n`edges[i]` is part of at least one shortest path. Otherwise, `answer[i]` is\n`false`.\n\nReturn the array `answer`.\n\nNote that the graph may not be connected.\n\n", "python_solution": "import math\nimport itertools\nimport bisect\nimport collections\nimport string\nimport heapq\nimport functools\nimport sortedcontainers\nfrom typing import List, Dict, Tuple, Iterator\n\nclass Solution:\n  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]\n\n  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist\n", "blocks": [{"type": "if", "start": 31, "end": 32, "difficulty": 1, "eg_cov_prob": 0.7547169811320755}, {"type": "if", "start": 34, "end": 36, "difficulty": 1, "eg_cov_prob": 0.8679245283018868}], "target_lines": [32, 35, 36]}
